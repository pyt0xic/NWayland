using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using NWayland.Protocols.Wayland;
using NWayland.Interop;
#nullable enable
// <auto-generated/>
namespace NWayland.Protocols.Wayland
{
    /// <summary>
    /// The core global object.  This is a special singleton object.  Itis used for internal Wayland protocol features.<br/><br/>
    /// </summary>
    public sealed unsafe partial class WlDisplay : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static WlDisplay()
        {
            NWayland.Protocols.Wayland.WlDisplay.WlInterface = new WlInterface("wl_display", 1, new WlMessage[] {
                new WlMessage("sync", "n", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlCallback.WlInterface) }),
                new WlMessage("get_registry", "n", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlRegistry.WlInterface) })
            }, new WlMessage[] {
                new WlMessage("error", "ous", new WlInterface*[] { null, null, null }),
                new WlMessage("delete_id", "u", new WlInterface*[] { null })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlDisplay.WlInterface);
        }

        /// <summary>
        /// The sync request asks the server to emit the 'done' eventon the returned wl_callback object.  Since requests arehandled in-order and events are delivered in-order, this canbe used as a barrier to ensure all previous requests and theresulting events have been handled.<br/><br/>
        /// The object returned by this request will be destroyed by thecompositor after the callback is fired and as such the client must notattempt to use it after that point.<br/><br/>
        /// The callback_data passed in the callback is the event serial.<br/><br/>
        /// </summary>
        public NWayland.Protocols.Wayland.WlCallback Sync()
        {
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 0, __args, ref NWayland.Protocols.Wayland.WlCallback.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.Wayland.WlCallback(__ret, Version);
        }

        /// <summary>
        /// This request creates a registry object that allows the clientto list and bind the global objects available from thecompositor.<br/><br/>
        /// It should be noted that the server side resources consumed inresponse to a get_registry request can only be released when theclient disconnects, not when the client side proxy is destroyed.Therefore, clients should invoke get_registry as infrequently aspossible to avoid wasting memory.<br/><br/>
        /// </summary>
        public NWayland.Protocols.Wayland.WlRegistry GetRegistry()
        {
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 1, __args, ref NWayland.Protocols.Wayland.WlRegistry.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.Wayland.WlRegistry(__ret, Version);
        }

        public interface IEvents
        {
            /// <summary>
            /// The error event is sent out when a fatal (non-recoverable)error has occurred.  The object_id argument is the objectwhere the error occurred, most often in response to a requestto that object.  The code identifies the error and is definedby the object interface.  As such, each interface defines itsown set of error codes.  The message is a brief descriptionof the error, for (debugging) convenience.<br/><br/>
            /// </summary>
            void OnError(NWayland.Protocols.Wayland.WlDisplay eventSender, WlProxy @objectId, uint @code, string @message);

            /// <summary>
            /// This event is used internally by the object ID managementlogic. When a client deletes an object that it had created,the server will send this event to acknowledge that it hasseen the delete request. When the client receives this event,it will know that it can safely reuse the object ID.<br/><br/>
            /// </summary>
            void OnDeleteId(NWayland.Protocols.Wayland.WlDisplay eventSender, uint @id);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnError(this, WlProxy.FromNative<WlProxy>(arguments[0].IntPtr), arguments[1].UInt32, Marshal.PtrToStringAnsi(arguments[2].IntPtr));
                    break;
                case 1:
                    Events?.OnDeleteId(this, arguments[0].UInt32);
                    break;
            }
        }

        /// <summary>
        /// These errors are global and can be emitted in response to anyserver request.<br/><br/>
        /// </summary>
        public enum ErrorEnum
        {
            /// <summary>
            /// server couldn't find object<br/><br/>
            /// </summary>
            InvalidObject = 0,
            /// <summary>
            /// method doesn't exist on the specified interface or malformed request<br/><br/>
            /// </summary>
            InvalidMethod = 1,
            /// <summary>
            /// server is out of memory<br/><br/>
            /// </summary>
            NoMemory = 2,
            /// <summary>
            /// implementation error in compositor<br/><br/>
            /// </summary>
            Implementation = 3
        }

        private class ProxyFactory : IBindFactory<WlDisplay>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlDisplay.WlInterface);
            }

            public WlDisplay Create(IntPtr handle, int version)
            {
                return new WlDisplay(handle, version);
            }
        }

        public static IBindFactory<WlDisplay> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "wl_display";
        public const int InterfaceVersion = 1;

        public WlDisplay(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// The singleton global registry object.  The server has a number ofglobal objects that are available to all clients.  These objectstypically represent an actual object in the server (for example,an input device) or they are singleton objects that provideextension functionality.<br/><br/>
    /// When a client creates a registry object, the registry objectwill emit a global event for each global currently in theregistry.  Globals come and go as a result of device ormonitor hotplugs, reconfiguration or other events, and theregistry will send out global and global_remove events tokeep the client up to date with the changes.  To mark the endof the initial burst of events, the client can use thewl_display.sync request immediately after callingwl_display.get_registry.<br/><br/>
    /// A client can bind to a global object by using the bindrequest.  This creates a client-side handle that lets the objectemit events to the client and lets the client invoke requests onthe object.<br/><br/>
    /// </summary>
    public sealed unsafe partial class WlRegistry : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static WlRegistry()
        {
            NWayland.Protocols.Wayland.WlRegistry.WlInterface = new WlInterface("wl_registry", 1, new WlMessage[] {
                new WlMessage("bind", "usun", new WlInterface*[] { null, null, null, null })
            }, new WlMessage[] {
                new WlMessage("global", "usu", new WlInterface*[] { null, null, null }),
                new WlMessage("global_remove", "u", new WlInterface*[] { null })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlRegistry.WlInterface);
        }

        public interface IEvents
        {
            /// <summary>
            /// Notify the client of global objects.<br/><br/>
            /// The event notifies the client that a global object withthe given name is now available, and it implements thegiven version of the given interface.<br/><br/>
            /// </summary>
            void OnGlobal(NWayland.Protocols.Wayland.WlRegistry eventSender, uint @name, string @interface, uint @version);

            /// <summary>
            /// Notify the client of removed global objects.<br/><br/>
            /// This event notifies the client that the global identifiedby name is no longer available.  If the client bound tothe global using the bind request, the client should nowdestroy that object.<br/><br/>
            /// The object remains valid and requests to the object will beignored until the client destroys it, to avoid races betweenthe global going away and a client sending a request to it.<br/><br/>
            /// </summary>
            void OnGlobalRemove(NWayland.Protocols.Wayland.WlRegistry eventSender, uint @name);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnGlobal(this, arguments[0].UInt32, Marshal.PtrToStringAnsi(arguments[1].IntPtr), arguments[2].UInt32);
                    break;
                case 1:
                    Events?.OnGlobalRemove(this, arguments[0].UInt32);
                    break;
            }
        }

        private class ProxyFactory : IBindFactory<WlRegistry>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlRegistry.WlInterface);
            }

            public WlRegistry Create(IntPtr handle, int version)
            {
                return new WlRegistry(handle, version);
            }
        }

        public static IBindFactory<WlRegistry> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "wl_registry";
        public const int InterfaceVersion = 1;

        public WlRegistry(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// Clients can handle the 'done' event to get notified whenthe related request is done.<br/><br/>
    /// </summary>
    public sealed unsafe partial class WlCallback : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static WlCallback()
        {
            NWayland.Protocols.Wayland.WlCallback.WlInterface = new WlInterface("wl_callback", 1, new WlMessage[] { }, new WlMessage[] {
                new WlMessage("done", "u", new WlInterface*[] { null })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlCallback.WlInterface);
        }

        public interface IEvents
        {
            /// <summary>
            /// Notify the client when the related request is done.<br/><br/>
            /// </summary>
            void OnDone(NWayland.Protocols.Wayland.WlCallback eventSender, uint @callbackData);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnDone(this, arguments[0].UInt32);
                    break;
            }
        }

        private class ProxyFactory : IBindFactory<WlCallback>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlCallback.WlInterface);
            }

            public WlCallback Create(IntPtr handle, int version)
            {
                return new WlCallback(handle, version);
            }
        }

        public static IBindFactory<WlCallback> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "wl_callback";
        public const int InterfaceVersion = 1;

        public WlCallback(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// A compositor.  This object is a singleton global.  Thecompositor is in charge of combining the contents of multiplesurfaces into one displayable output.<br/><br/>
    /// </summary>
    public sealed unsafe partial class WlCompositor : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static WlCompositor()
        {
            NWayland.Protocols.Wayland.WlCompositor.WlInterface = new WlInterface("wl_compositor", 5, new WlMessage[] {
                new WlMessage("create_surface", "n", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface) }),
                new WlMessage("create_region", "n", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlRegion.WlInterface) })
            }, new WlMessage[] { });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlCompositor.WlInterface);
        }

        /// <summary>
        /// Ask the compositor to create a new surface.<br/><br/>
        /// </summary>
        public NWayland.Protocols.Wayland.WlSurface CreateSurface()
        {
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 0, __args, ref NWayland.Protocols.Wayland.WlSurface.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.Wayland.WlSurface(__ret, Version);
        }

        /// <summary>
        /// Ask the compositor to create a new region.<br/><br/>
        /// </summary>
        public NWayland.Protocols.Wayland.WlRegion CreateRegion()
        {
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 1, __args, ref NWayland.Protocols.Wayland.WlRegion.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.Wayland.WlRegion(__ret, Version);
        }

        public interface IEvents
        {
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
        }

        private class ProxyFactory : IBindFactory<WlCompositor>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlCompositor.WlInterface);
            }

            public WlCompositor Create(IntPtr handle, int version)
            {
                return new WlCompositor(handle, version);
            }
        }

        public static IBindFactory<WlCompositor> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "wl_compositor";
        public const int InterfaceVersion = 5;

        public WlCompositor(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// The wl_shm_pool object encapsulates a piece of memory sharedbetween the compositor and client.  Through the wl_shm_poolobject, the client can allocate shared memory wl_buffer objects.All objects created through the same pool share the sameunderlying mapped memory. Reusing the mapped memory avoids thesetup/teardown overhead and is useful when interactively resizinga surface or for many small buffers.<br/><br/>
    /// </summary>
    public sealed unsafe partial class WlShmPool : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static WlShmPool()
        {
            NWayland.Protocols.Wayland.WlShmPool.WlInterface = new WlInterface("wl_shm_pool", 1, new WlMessage[] {
                new WlMessage("create_buffer", "niiiiu", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlBuffer.WlInterface), null, null, null, null, null }),
                new WlMessage("destroy", "", new WlInterface*[] { }),
                new WlMessage("resize", "i", new WlInterface*[] { null })
            }, new WlMessage[] { });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlShmPool.WlInterface);
        }

        /// <summary>
        /// Create a wl_buffer object from the pool.<br/><br/>
        /// The buffer is created offset bytes into the pool and haswidth and height as specified.  The stride argument specifiesthe number of bytes from the beginning of one row to the beginningof the next.  The format is the pixel format of the buffer andmust be one of those advertised through the wl_shm.format event.<br/><br/>
        /// A buffer will keep a reference to the pool it was created fromso it is valid to destroy the pool immediately after creatinga buffer from it.<br/><br/>
        /// </summary>
        public NWayland.Protocols.Wayland.WlBuffer CreateBuffer(int @offset, int @width, int @height, int @stride, NWayland.Protocols.Wayland.WlShm.FormatEnum @format)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId,
                @offset,
                @width,
                @height,
                @stride,
                (uint)@format
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 0, __args, ref NWayland.Protocols.Wayland.WlBuffer.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.Wayland.WlBuffer(__ret, Version);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
            base.Dispose(true);
        }

        /// <summary>
        /// This request will cause the server to remap the backing memoryfor the pool from the file descriptor passed when the pool wascreated, but using the new size.  This request can only beused to make the pool bigger.<br/><br/>
        /// This request only changes the amount of bytes that are mmappedby the server and does not touch the file corresponding to thefile descriptor passed at creation time. It is the client'sresponsibility to ensure that the file is at least as big asthe new pool size.<br/><br/>
        /// </summary>
        public void Resize(int @size)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                @size
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 2, __args);
        }

        public interface IEvents
        {
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
        }

        private class ProxyFactory : IBindFactory<WlShmPool>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlShmPool.WlInterface);
            }

            public WlShmPool Create(IntPtr handle, int version)
            {
                return new WlShmPool(handle, version);
            }
        }

        public static IBindFactory<WlShmPool> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "wl_shm_pool";
        public const int InterfaceVersion = 1;

        public WlShmPool(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// A singleton global object that provides support for sharedmemory.<br/><br/>
    /// Clients can create wl_shm_pool objects using the create_poolrequest.<br/><br/>
    /// On binding the wl_shm object one or more format eventsare emitted to inform clients about the valid pixel formatsthat can be used for buffers.<br/><br/>
    /// </summary>
    public sealed unsafe partial class WlShm : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static WlShm()
        {
            NWayland.Protocols.Wayland.WlShm.WlInterface = new WlInterface("wl_shm", 1, new WlMessage[] {
                new WlMessage("create_pool", "nhi", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlShmPool.WlInterface), null, null })
            }, new WlMessage[] {
                new WlMessage("format", "u", new WlInterface*[] { null })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlShm.WlInterface);
        }

        /// <summary>
        /// Create a new wl_shm_pool object.<br/><br/>
        /// The pool can be used to create shared memory based bufferobjects.  The server will mmap size bytes of the passed filedescriptor, to use as backing memory for the pool.<br/><br/>
        /// </summary>
        public NWayland.Protocols.Wayland.WlShmPool CreatePool(int @fd, int @size)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId,
                @fd,
                @size
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 0, __args, ref NWayland.Protocols.Wayland.WlShmPool.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.Wayland.WlShmPool(__ret, Version);
        }

        public interface IEvents
        {
            /// <summary>
            /// Informs the client about a valid pixel format thatcan be used for buffers. Known formats includeargb8888 and xrgb8888.<br/><br/>
            /// </summary>
            void OnFormat(NWayland.Protocols.Wayland.WlShm eventSender, FormatEnum @format);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnFormat(this, (FormatEnum)arguments[0].UInt32);
                    break;
            }
        }

        /// <summary>
        /// These errors can be emitted in response to wl_shm requests.<br/><br/>
        /// </summary>
        public enum ErrorEnum
        {
            /// <summary>
            /// buffer format is not known<br/><br/>
            /// </summary>
            InvalidFormat = 0,
            /// <summary>
            /// invalid size or stride during pool or buffer creation<br/><br/>
            /// </summary>
            InvalidStride = 1,
            /// <summary>
            /// mmapping the file descriptor failed<br/><br/>
            /// </summary>
            InvalidFd = 2
        }

        /// <summary>
        /// This describes the memory layout of an individual pixel.<br/><br/>
        /// All renderers should support argb8888 and xrgb8888 but any otherformats are optional and may not be supported by the particularrenderer in use.<br/><br/>
        /// The drm format codes match the macros defined in drm_fourcc.h, exceptargb8888 and xrgb8888. The formats actually supported by the compositorwill be reported by the format event.<br/><br/>
        /// For all wl_shm formats and unless specified in another protocolextension, pre-multiplied alpha is used for pixel values.<br/><br/>
        /// </summary>
        public enum FormatEnum
        {
            /// <summary>
            /// 32-bit ARGB format, [31:0] A:R:G:B 8:8:8:8 little endian<br/><br/>
            /// </summary>
            Argb8888 = 0,
            /// <summary>
            /// 32-bit RGB format, [31:0] x:R:G:B 8:8:8:8 little endian<br/><br/>
            /// </summary>
            Xrgb8888 = 1,
            /// <summary>
            /// 8-bit color index format, [7:0] C<br/><br/>
            /// </summary>
            C8 = 0x20203843,
            /// <summary>
            /// 8-bit RGB format, [7:0] R:G:B 3:3:2<br/><br/>
            /// </summary>
            Rgb332 = 0x38424752,
            /// <summary>
            /// 8-bit BGR format, [7:0] B:G:R 2:3:3<br/><br/>
            /// </summary>
            Bgr233 = 0x38524742,
            /// <summary>
            /// 16-bit xRGB format, [15:0] x:R:G:B 4:4:4:4 little endian<br/><br/>
            /// </summary>
            Xrgb4444 = 0x32315258,
            /// <summary>
            /// 16-bit xBGR format, [15:0] x:B:G:R 4:4:4:4 little endian<br/><br/>
            /// </summary>
            Xbgr4444 = 0x32314258,
            /// <summary>
            /// 16-bit RGBx format, [15:0] R:G:B:x 4:4:4:4 little endian<br/><br/>
            /// </summary>
            Rgbx4444 = 0x32315852,
            /// <summary>
            /// 16-bit BGRx format, [15:0] B:G:R:x 4:4:4:4 little endian<br/><br/>
            /// </summary>
            Bgrx4444 = 0x32315842,
            /// <summary>
            /// 16-bit ARGB format, [15:0] A:R:G:B 4:4:4:4 little endian<br/><br/>
            /// </summary>
            Argb4444 = 0x32315241,
            /// <summary>
            /// 16-bit ABGR format, [15:0] A:B:G:R 4:4:4:4 little endian<br/><br/>
            /// </summary>
            Abgr4444 = 0x32314241,
            /// <summary>
            /// 16-bit RBGA format, [15:0] R:G:B:A 4:4:4:4 little endian<br/><br/>
            /// </summary>
            Rgba4444 = 0x32314152,
            /// <summary>
            /// 16-bit BGRA format, [15:0] B:G:R:A 4:4:4:4 little endian<br/><br/>
            /// </summary>
            Bgra4444 = 0x32314142,
            /// <summary>
            /// 16-bit xRGB format, [15:0] x:R:G:B 1:5:5:5 little endian<br/><br/>
            /// </summary>
            Xrgb1555 = 0x35315258,
            /// <summary>
            /// 16-bit xBGR 1555 format, [15:0] x:B:G:R 1:5:5:5 little endian<br/><br/>
            /// </summary>
            Xbgr1555 = 0x35314258,
            /// <summary>
            /// 16-bit RGBx 5551 format, [15:0] R:G:B:x 5:5:5:1 little endian<br/><br/>
            /// </summary>
            Rgbx5551 = 0x35315852,
            /// <summary>
            /// 16-bit BGRx 5551 format, [15:0] B:G:R:x 5:5:5:1 little endian<br/><br/>
            /// </summary>
            Bgrx5551 = 0x35315842,
            /// <summary>
            /// 16-bit ARGB 1555 format, [15:0] A:R:G:B 1:5:5:5 little endian<br/><br/>
            /// </summary>
            Argb1555 = 0x35315241,
            /// <summary>
            /// 16-bit ABGR 1555 format, [15:0] A:B:G:R 1:5:5:5 little endian<br/><br/>
            /// </summary>
            Abgr1555 = 0x35314241,
            /// <summary>
            /// 16-bit RGBA 5551 format, [15:0] R:G:B:A 5:5:5:1 little endian<br/><br/>
            /// </summary>
            Rgba5551 = 0x35314152,
            /// <summary>
            /// 16-bit BGRA 5551 format, [15:0] B:G:R:A 5:5:5:1 little endian<br/><br/>
            /// </summary>
            Bgra5551 = 0x35314142,
            /// <summary>
            /// 16-bit RGB 565 format, [15:0] R:G:B 5:6:5 little endian<br/><br/>
            /// </summary>
            Rgb565 = 0x36314752,
            /// <summary>
            /// 16-bit BGR 565 format, [15:0] B:G:R 5:6:5 little endian<br/><br/>
            /// </summary>
            Bgr565 = 0x36314742,
            /// <summary>
            /// 24-bit RGB format, [23:0] R:G:B little endian<br/><br/>
            /// </summary>
            Rgb888 = 0x34324752,
            /// <summary>
            /// 24-bit BGR format, [23:0] B:G:R little endian<br/><br/>
            /// </summary>
            Bgr888 = 0x34324742,
            /// <summary>
            /// 32-bit xBGR format, [31:0] x:B:G:R 8:8:8:8 little endian<br/><br/>
            /// </summary>
            Xbgr8888 = 0x34324258,
            /// <summary>
            /// 32-bit RGBx format, [31:0] R:G:B:x 8:8:8:8 little endian<br/><br/>
            /// </summary>
            Rgbx8888 = 0x34325852,
            /// <summary>
            /// 32-bit BGRx format, [31:0] B:G:R:x 8:8:8:8 little endian<br/><br/>
            /// </summary>
            Bgrx8888 = 0x34325842,
            /// <summary>
            /// 32-bit ABGR format, [31:0] A:B:G:R 8:8:8:8 little endian<br/><br/>
            /// </summary>
            Abgr8888 = 0x34324241,
            /// <summary>
            /// 32-bit RGBA format, [31:0] R:G:B:A 8:8:8:8 little endian<br/><br/>
            /// </summary>
            Rgba8888 = 0x34324152,
            /// <summary>
            /// 32-bit BGRA format, [31:0] B:G:R:A 8:8:8:8 little endian<br/><br/>
            /// </summary>
            Bgra8888 = 0x34324142,
            /// <summary>
            /// 32-bit xRGB format, [31:0] x:R:G:B 2:10:10:10 little endian<br/><br/>
            /// </summary>
            Xrgb2101010 = 0x30335258,
            /// <summary>
            /// 32-bit xBGR format, [31:0] x:B:G:R 2:10:10:10 little endian<br/><br/>
            /// </summary>
            Xbgr2101010 = 0x30334258,
            /// <summary>
            /// 32-bit RGBx format, [31:0] R:G:B:x 10:10:10:2 little endian<br/><br/>
            /// </summary>
            Rgbx1010102 = 0x30335852,
            /// <summary>
            /// 32-bit BGRx format, [31:0] B:G:R:x 10:10:10:2 little endian<br/><br/>
            /// </summary>
            Bgrx1010102 = 0x30335842,
            /// <summary>
            /// 32-bit ARGB format, [31:0] A:R:G:B 2:10:10:10 little endian<br/><br/>
            /// </summary>
            Argb2101010 = 0x30335241,
            /// <summary>
            /// 32-bit ABGR format, [31:0] A:B:G:R 2:10:10:10 little endian<br/><br/>
            /// </summary>
            Abgr2101010 = 0x30334241,
            /// <summary>
            /// 32-bit RGBA format, [31:0] R:G:B:A 10:10:10:2 little endian<br/><br/>
            /// </summary>
            Rgba1010102 = 0x30334152,
            /// <summary>
            /// 32-bit BGRA format, [31:0] B:G:R:A 10:10:10:2 little endian<br/><br/>
            /// </summary>
            Bgra1010102 = 0x30334142,
            /// <summary>
            /// packed YCbCr format, [31:0] Cr0:Y1:Cb0:Y0 8:8:8:8 little endian<br/><br/>
            /// </summary>
            Yuyv = 0x56595559,
            /// <summary>
            /// packed YCbCr format, [31:0] Cb0:Y1:Cr0:Y0 8:8:8:8 little endian<br/><br/>
            /// </summary>
            Yvyu = 0x55595659,
            /// <summary>
            /// packed YCbCr format, [31:0] Y1:Cr0:Y0:Cb0 8:8:8:8 little endian<br/><br/>
            /// </summary>
            Uyvy = 0x59565955,
            /// <summary>
            /// packed YCbCr format, [31:0] Y1:Cb0:Y0:Cr0 8:8:8:8 little endian<br/><br/>
            /// </summary>
            Vyuy = 0x59555956,
            /// <summary>
            /// packed AYCbCr format, [31:0] A:Y:Cb:Cr 8:8:8:8 little endian<br/><br/>
            /// </summary>
            Ayuv = 0x56555941,
            /// <summary>
            /// 2 plane YCbCr Cr:Cb format, 2x2 subsampled Cr:Cb plane<br/><br/>
            /// </summary>
            Nv12 = 0x3231564e,
            /// <summary>
            /// 2 plane YCbCr Cb:Cr format, 2x2 subsampled Cb:Cr plane<br/><br/>
            /// </summary>
            Nv21 = 0x3132564e,
            /// <summary>
            /// 2 plane YCbCr Cr:Cb format, 2x1 subsampled Cr:Cb plane<br/><br/>
            /// </summary>
            Nv16 = 0x3631564e,
            /// <summary>
            /// 2 plane YCbCr Cb:Cr format, 2x1 subsampled Cb:Cr plane<br/><br/>
            /// </summary>
            Nv61 = 0x3136564e,
            /// <summary>
            /// 3 plane YCbCr format, 4x4 subsampled Cb (1) and Cr (2) planes<br/><br/>
            /// </summary>
            Yuv410 = 0x39565559,
            /// <summary>
            /// 3 plane YCbCr format, 4x4 subsampled Cr (1) and Cb (2) planes<br/><br/>
            /// </summary>
            Yvu410 = 0x39555659,
            /// <summary>
            /// 3 plane YCbCr format, 4x1 subsampled Cb (1) and Cr (2) planes<br/><br/>
            /// </summary>
            Yuv411 = 0x31315559,
            /// <summary>
            /// 3 plane YCbCr format, 4x1 subsampled Cr (1) and Cb (2) planes<br/><br/>
            /// </summary>
            Yvu411 = 0x31315659,
            /// <summary>
            /// 3 plane YCbCr format, 2x2 subsampled Cb (1) and Cr (2) planes<br/><br/>
            /// </summary>
            Yuv420 = 0x32315559,
            /// <summary>
            /// 3 plane YCbCr format, 2x2 subsampled Cr (1) and Cb (2) planes<br/><br/>
            /// </summary>
            Yvu420 = 0x32315659,
            /// <summary>
            /// 3 plane YCbCr format, 2x1 subsampled Cb (1) and Cr (2) planes<br/><br/>
            /// </summary>
            Yuv422 = 0x36315559,
            /// <summary>
            /// 3 plane YCbCr format, 2x1 subsampled Cr (1) and Cb (2) planes<br/><br/>
            /// </summary>
            Yvu422 = 0x36315659,
            /// <summary>
            /// 3 plane YCbCr format, non-subsampled Cb (1) and Cr (2) planes<br/><br/>
            /// </summary>
            Yuv444 = 0x34325559,
            /// <summary>
            /// 3 plane YCbCr format, non-subsampled Cr (1) and Cb (2) planes<br/><br/>
            /// </summary>
            Yvu444 = 0x34325659,
            /// <summary>
            /// [7:0] R<br/><br/>
            /// </summary>
            R8 = 0x20203852,
            /// <summary>
            /// [15:0] R little endian<br/><br/>
            /// </summary>
            R16 = 0x20363152,
            /// <summary>
            /// [15:0] R:G 8:8 little endian<br/><br/>
            /// </summary>
            Rg88 = 0x38384752,
            /// <summary>
            /// [15:0] G:R 8:8 little endian<br/><br/>
            /// </summary>
            Gr88 = 0x38385247,
            /// <summary>
            /// [31:0] R:G 16:16 little endian<br/><br/>
            /// </summary>
            Rg1616 = 0x32334752,
            /// <summary>
            /// [31:0] G:R 16:16 little endian<br/><br/>
            /// </summary>
            Gr1616 = 0x32335247,
            /// <summary>
            /// [63:0] x:R:G:B 16:16:16:16 little endian<br/><br/>
            /// </summary>
            Xrgb16161616f = 0x48345258,
            /// <summary>
            /// [63:0] x:B:G:R 16:16:16:16 little endian<br/><br/>
            /// </summary>
            Xbgr16161616f = 0x48344258,
            /// <summary>
            /// [63:0] A:R:G:B 16:16:16:16 little endian<br/><br/>
            /// </summary>
            Argb16161616f = 0x48345241,
            /// <summary>
            /// [63:0] A:B:G:R 16:16:16:16 little endian<br/><br/>
            /// </summary>
            Abgr16161616f = 0x48344241,
            /// <summary>
            /// [31:0] X:Y:Cb:Cr 8:8:8:8 little endian<br/><br/>
            /// </summary>
            Xyuv8888 = 0x56555958,
            /// <summary>
            /// [23:0] Cr:Cb:Y 8:8:8 little endian<br/><br/>
            /// </summary>
            Vuy888 = 0x34325556,
            /// <summary>
            /// Y followed by U then V, 10:10:10. Non-linear modifier only<br/><br/>
            /// </summary>
            Vuy101010 = 0x30335556,
            /// <summary>
            /// [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 10:6:10:6:10:6:10:6 little endian per 2 Y pixels<br/><br/>
            /// </summary>
            Y210 = 0x30313259,
            /// <summary>
            /// [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 12:4:12:4:12:4:12:4 little endian per 2 Y pixels<br/><br/>
            /// </summary>
            Y212 = 0x32313259,
            /// <summary>
            /// [63:0] Cr0:Y1:Cb0:Y0 16:16:16:16 little endian per 2 Y pixels<br/><br/>
            /// </summary>
            Y216 = 0x36313259,
            /// <summary>
            /// [31:0] A:Cr:Y:Cb 2:10:10:10 little endian<br/><br/>
            /// </summary>
            Y410 = 0x30313459,
            /// <summary>
            /// [63:0] A:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian<br/><br/>
            /// </summary>
            Y412 = 0x32313459,
            /// <summary>
            /// [63:0] A:Cr:Y:Cb 16:16:16:16 little endian<br/><br/>
            /// </summary>
            Y416 = 0x36313459,
            /// <summary>
            /// [31:0] X:Cr:Y:Cb 2:10:10:10 little endian<br/><br/>
            /// </summary>
            Xvyu2101010 = 0x30335658,
            /// <summary>
            /// [63:0] X:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian<br/><br/>
            /// </summary>
            Xvyu1216161616 = 0x36335658,
            /// <summary>
            /// [63:0] X:Cr:Y:Cb 16:16:16:16 little endian<br/><br/>
            /// </summary>
            Xvyu16161616 = 0x38345658,
            /// <summary>
            /// [63:0]   A3:A2:Y3:0:Cr0:0:Y2:0:A1:A0:Y1:0:Cb0:0:Y0:0  1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian<br/><br/>
            /// </summary>
            Y0l0 = 0x304c3059,
            /// <summary>
            /// [63:0]   X3:X2:Y3:0:Cr0:0:Y2:0:X1:X0:Y1:0:Cb0:0:Y0:0  1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian<br/><br/>
            /// </summary>
            X0l0 = 0x304c3058,
            /// <summary>
            /// [63:0]   A3:A2:Y3:Cr0:Y2:A1:A0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian<br/><br/>
            /// </summary>
            Y0l2 = 0x324c3059,
            /// <summary>
            /// [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian<br/><br/>
            /// </summary>
            X0l2 = 0x324c3058,
            Yuv4208bit = 0x38305559,
            Yuv42010bit = 0x30315559,
            Xrgb8888A8 = 0x38415258,
            Xbgr8888A8 = 0x38414258,
            Rgbx8888A8 = 0x38415852,
            Bgrx8888A8 = 0x38415842,
            Rgb888A8 = 0x38413852,
            Bgr888A8 = 0x38413842,
            Rgb565A8 = 0x38413552,
            Bgr565A8 = 0x38413542,
            /// <summary>
            /// non-subsampled Cr:Cb plane<br/><br/>
            /// </summary>
            Nv24 = 0x3432564e,
            /// <summary>
            /// non-subsampled Cb:Cr plane<br/><br/>
            /// </summary>
            Nv42 = 0x3234564e,
            /// <summary>
            /// 2x1 subsampled Cr:Cb plane, 10 bit per channel<br/><br/>
            /// </summary>
            P210 = 0x30313250,
            /// <summary>
            /// 2x2 subsampled Cr:Cb plane 10 bits per channel<br/><br/>
            /// </summary>
            P010 = 0x30313050,
            /// <summary>
            /// 2x2 subsampled Cr:Cb plane 12 bits per channel<br/><br/>
            /// </summary>
            P012 = 0x32313050,
            /// <summary>
            /// 2x2 subsampled Cr:Cb plane 16 bits per channel<br/><br/>
            /// </summary>
            P016 = 0x36313050,
            /// <summary>
            /// [63:0] A:x:B:x:G:x:R:x 10:6:10:6:10:6:10:6 little endian<br/><br/>
            /// </summary>
            Axbxgxrx106106106106 = 0x30314241,
            /// <summary>
            /// 2x2 subsampled Cr:Cb plane<br/><br/>
            /// </summary>
            Nv15 = 0x3531564e,
            Q410 = 0x30313451,
            Q401 = 0x31303451,
            /// <summary>
            /// [63:0] x:R:G:B 16:16:16:16 little endian<br/><br/>
            /// </summary>
            Xrgb16161616 = 0x38345258,
            /// <summary>
            /// [63:0] x:B:G:R 16:16:16:16 little endian<br/><br/>
            /// </summary>
            Xbgr16161616 = 0x38344258,
            /// <summary>
            /// [63:0] A:R:G:B 16:16:16:16 little endian<br/><br/>
            /// </summary>
            Argb16161616 = 0x38345241,
            /// <summary>
            /// [63:0] A:B:G:R 16:16:16:16 little endian<br/><br/>
            /// </summary>
            Abgr16161616 = 0x38344241
        }

        private class ProxyFactory : IBindFactory<WlShm>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlShm.WlInterface);
            }

            public WlShm Create(IntPtr handle, int version)
            {
                return new WlShm(handle, version);
            }
        }

        public static IBindFactory<WlShm> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "wl_shm";
        public const int InterfaceVersion = 1;

        public WlShm(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// A buffer provides the content for a wl_surface. Buffers arecreated through factory interfaces such as wl_shm, wp_linux_buffer_params(from the linux-dmabuf protocol extension) or similar. It has a width anda height and can be attached to a wl_surface, but the mechanism by which aclient provides and updates the contents is defined by the buffer factoryinterface.<br/><br/>
    /// If the buffer uses a format that has an alpha channel, the alpha channelis assumed to be premultiplied in the color channels unless otherwisespecified.<br/><br/>
    /// </summary>
    public sealed unsafe partial class WlBuffer : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static WlBuffer()
        {
            NWayland.Protocols.Wayland.WlBuffer.WlInterface = new WlInterface("wl_buffer", 1, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("release", "", new WlInterface*[] { })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlBuffer.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
            /// <summary>
            /// Sent when this wl_buffer is no longer used by the compositor.The client is now free to reuse or destroy this buffer and itsbacking storage.<br/><br/>
            /// If a client receives a release event before the frame callbackrequested in the same wl_surface.commit that attaches thiswl_buffer to a surface, then the client is immediately free toreuse the buffer and its backing storage, and does not need asecond buffer for the next surface content update. Typicallythis is possible, when the compositor maintains a copy of thewl_surface contents, e.g. as a GL texture. This is an importantoptimization for GL(ES) compositors with wl_shm clients.<br/><br/>
            /// </summary>
            void OnRelease(NWayland.Protocols.Wayland.WlBuffer eventSender);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnRelease(this);
                    break;
            }
        }

        private class ProxyFactory : IBindFactory<WlBuffer>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlBuffer.WlInterface);
            }

            public WlBuffer Create(IntPtr handle, int version)
            {
                return new WlBuffer(handle, version);
            }
        }

        public static IBindFactory<WlBuffer> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "wl_buffer";
        public const int InterfaceVersion = 1;

        public WlBuffer(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// A wl_data_offer represents a piece of data offered for transferby another client (the source client).  It is used by thecopy-and-paste and drag-and-drop mechanisms.  The offerdescribes the different mime types that the data can beconverted to and provides the mechanism for transferring thedata directly from the source client.<br/><br/>
    /// </summary>
    public sealed unsafe partial class WlDataOffer : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static WlDataOffer()
        {
            NWayland.Protocols.Wayland.WlDataOffer.WlInterface = new WlInterface("wl_data_offer", 3, new WlMessage[] {
                new WlMessage("accept", "u?s", new WlInterface*[] { null, null }),
                new WlMessage("receive", "sh", new WlInterface*[] { null, null }),
                new WlMessage("destroy", "", new WlInterface*[] { }),
                new WlMessage("finish", "3", new WlInterface*[] { }),
                new WlMessage("set_actions", "3uu", new WlInterface*[] { null, null })
            }, new WlMessage[] {
                new WlMessage("offer", "s", new WlInterface*[] { null }),
                new WlMessage("source_actions", "3u", new WlInterface*[] { null }),
                new WlMessage("action", "3u", new WlInterface*[] { null })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlDataOffer.WlInterface);
        }

        /// <summary>
        /// Indicate that the client can accept the given mime type, orNULL for not accepted.<br/><br/>
        /// For objects of version 2 or older, this request is used by theclient to give feedback whether the client can receive the givenmime type, or NULL if none is accepted; the feedback does notdetermine whether the drag-and-drop operation succeeds or not.<br/><br/>
        /// For objects of version 3 or newer, this request determines thefinal result of the drag-and-drop operation. If the end resultis that no mime types were accepted, the drag-and-drop operationwill be cancelled and the corresponding drag source will receivewl_data_source.cancelled. Clients may still use this event inconjunction with wl_data_source.action for feedback.<br/><br/>
        /// </summary>
        public void Accept(uint @serial, string? @mimeType)
        {
            using var __marshalled__mimeType = new NWaylandMarshalledString(@mimeType);
            WlArgument* __args = stackalloc WlArgument[] {
                @serial,
                __marshalled__mimeType
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
        }

        /// <summary>
        /// To transfer the offered data, the client issues this requestand indicates the mime type it wants to receive.  The transferhappens through the passed file descriptor (typically createdwith the pipe system call).  The source client writes the datain the mime type representation requested and then closes thefile descriptor.<br/><br/>
        /// The receiving client reads from the read end of the pipe untilEOF and then closes its end, at which point the transfer iscomplete.<br/><br/>
        /// This request may happen multiple times for different mime types,both before and after wl_data_device.drop. Drag-and-drop destinationclients may preemptively fetch data or examine it more closely todetermine acceptance.<br/><br/>
        /// </summary>
        public void Receive(string @mimeType, int @fd)
        {
            if (@mimeType == null)
                throw new ArgumentNullException("mimeType");
            using var __marshalled__mimeType = new NWaylandMarshalledString(@mimeType);
            WlArgument* __args = stackalloc WlArgument[] {
                __marshalled__mimeType,
                @fd
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 2, __args);
            base.Dispose(true);
        }

        /// <summary>
        /// Notifies the compositor that the drag destination successfullyfinished the drag-and-drop operation.<br/><br/>
        /// Upon receiving this request, the compositor will emitwl_data_source.dnd_finished on the drag source client.<br/><br/>
        /// It is a client error to perform other requests thanwl_data_offer.destroy after this one. It is also an error to performthis request after a NULL mime type has been set inwl_data_offer.accept or no action was received throughwl_data_offer.action.<br/><br/>
        /// If wl_data_offer.finish request is received for a non drag and dropoperation, the invalid_finish protocol error is raised.<br/><br/>
        /// </summary>
        public void Finish()
        {
            if (Version < 3)
                throw new InvalidOperationException("Request finish is only supported since version 3");
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 3, __args);
        }

        /// <summary>
        /// Sets the actions that the destination side client supports forthis operation. This request may trigger the emission ofwl_data_source.action and wl_data_offer.action events if the compositorneeds to change the selected action.<br/><br/>
        /// This request can be called multiple times throughout thedrag-and-drop operation, typically in response to wl_data_device.enteror wl_data_device.motion events.<br/><br/>
        /// This request determines the final result of the drag-and-dropoperation. If the end result is that no action is accepted,the drag source will receive wl_data_source.cancelled.<br/><br/>
        /// The dnd_actions argument must contain only values expressed in thewl_data_device_manager.dnd_actions enum, and the preferred_actionargument must only contain one of those values set, otherwise itwill result in a protocol error.<br/><br/>
        /// While managing an "ask" action, the destination drag-and-drop clientmay perform further wl_data_offer.receive requests, and is expectedto perform one last wl_data_offer.set_actions request with a preferredaction other than "ask" (and optionally wl_data_offer.accept) beforerequesting wl_data_offer.finish, in order to convey the action selectedby the user. If the preferred action is not in thewl_data_offer.source_actions mask, an error will be raised.<br/><br/>
        /// If the "ask" action is dismissed (e.g. user cancellation), the clientis expected to perform wl_data_offer.destroy right away.<br/><br/>
        /// This request can only be made on drag-and-drop offers, a protocol errorwill be raised otherwise.<br/><br/>
        /// </summary>
        public void SetActions(NWayland.Protocols.Wayland.WlDataDeviceManager.DndActionEnum @dndActions, NWayland.Protocols.Wayland.WlDataDeviceManager.DndActionEnum @preferredAction)
        {
            if (Version < 3)
                throw new InvalidOperationException("Request set_actions is only supported since version 3");
            WlArgument* __args = stackalloc WlArgument[] {
                (uint)@dndActions,
                (uint)@preferredAction
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 4, __args);
        }

        public interface IEvents
        {
            /// <summary>
            /// Sent immediately after creating the wl_data_offer object.  Oneevent per offered mime type.<br/><br/>
            /// </summary>
            void OnOffer(NWayland.Protocols.Wayland.WlDataOffer eventSender, string @mimeType);

            /// <summary>
            /// This event indicates the actions offered by the data source. Itwill be sent right after wl_data_device.enter, or anytime the sourceside changes its offered actions through wl_data_source.set_actions.<br/><br/>
            /// </summary>
            void OnSourceActions(NWayland.Protocols.Wayland.WlDataOffer eventSender, NWayland.Protocols.Wayland.WlDataDeviceManager.DndActionEnum @sourceActions);

            /// <summary>
            /// This event indicates the action selected by the compositor aftermatching the source/destination side actions. Only one action (ornone) will be offered here.<br/><br/>
            /// This event can be emitted multiple times during the drag-and-dropoperation in response to destination side action changes throughwl_data_offer.set_actions.<br/><br/>
            /// This event will no longer be emitted after wl_data_device.drophappened on the drag-and-drop destination, the client musthonor the last action received, or the last preferred one setthrough wl_data_offer.set_actions when handling an "ask" action.<br/><br/>
            /// Compositors may also change the selected action on the fly, mainlyin response to keyboard modifier changes during the drag-and-dropoperation.<br/><br/>
            /// The most recent action received is always the valid one. Prior toreceiving wl_data_device.drop, the chosen action may change (e.g.due to keyboard modifiers being pressed). At the time of receivingwl_data_device.drop the drag-and-drop destination must honor thelast action received.<br/><br/>
            /// Action changes may still happen after wl_data_device.drop,especially on "ask" actions, where the drag-and-drop destinationmay choose another action afterwards. Action changes happeningat this stage are always the result of inter-client negotiation, thecompositor shall no longer be able to induce a different action.<br/><br/>
            /// Upon "ask" actions, it is expected that the drag-and-drop destinationmay potentially choose a different action and/or mime type,based on wl_data_offer.source_actions and finally chosen by theuser (e.g. popping up a menu with the available options). Thefinal wl_data_offer.set_actions and wl_data_offer.accept requestsmust happen before the call to wl_data_offer.finish.<br/><br/>
            /// </summary>
            void OnAction(NWayland.Protocols.Wayland.WlDataOffer eventSender, NWayland.Protocols.Wayland.WlDataDeviceManager.DndActionEnum @dndAction);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnOffer(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr));
                    break;
                case 1:
                    Events?.OnSourceActions(this, (NWayland.Protocols.Wayland.WlDataDeviceManager.DndActionEnum)arguments[0].UInt32);
                    break;
                case 2:
                    Events?.OnAction(this, (NWayland.Protocols.Wayland.WlDataDeviceManager.DndActionEnum)arguments[0].UInt32);
                    break;
            }
        }

        public enum ErrorEnum
        {
            /// <summary>
            /// finish request was called untimely<br/><br/>
            /// </summary>
            InvalidFinish = 0,
            /// <summary>
            /// action mask contains invalid values<br/><br/>
            /// </summary>
            InvalidActionMask = 1,
            /// <summary>
            /// action argument has an invalid value<br/><br/>
            /// </summary>
            InvalidAction = 2,
            /// <summary>
            /// offer doesn't accept this request<br/><br/>
            /// </summary>
            InvalidOffer = 3
        }

        private class ProxyFactory : IBindFactory<WlDataOffer>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlDataOffer.WlInterface);
            }

            public WlDataOffer Create(IntPtr handle, int version)
            {
                return new WlDataOffer(handle, version);
            }
        }

        public static IBindFactory<WlDataOffer> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "wl_data_offer";
        public const int InterfaceVersion = 3;

        public WlDataOffer(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// The wl_data_source object is the source side of a wl_data_offer.It is created by the source client in a data transfer andprovides a way to describe the offered data and a way to respondto requests to transfer the data.<br/><br/>
    /// </summary>
    public sealed unsafe partial class WlDataSource : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static WlDataSource()
        {
            NWayland.Protocols.Wayland.WlDataSource.WlInterface = new WlInterface("wl_data_source", 3, new WlMessage[] {
                new WlMessage("offer", "s", new WlInterface*[] { null }),
                new WlMessage("destroy", "", new WlInterface*[] { }),
                new WlMessage("set_actions", "3u", new WlInterface*[] { null })
            }, new WlMessage[] {
                new WlMessage("target", "?s", new WlInterface*[] { null }),
                new WlMessage("send", "sh", new WlInterface*[] { null, null }),
                new WlMessage("cancelled", "", new WlInterface*[] { }),
                new WlMessage("dnd_drop_performed", "3", new WlInterface*[] { }),
                new WlMessage("dnd_finished", "3", new WlInterface*[] { }),
                new WlMessage("action", "3u", new WlInterface*[] { null })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlDataSource.WlInterface);
        }

        /// <summary>
        /// This request adds a mime type to the set of mime typesadvertised to targets.  Can be called several times to offermultiple types.<br/><br/>
        /// </summary>
        public void Offer(string @mimeType)
        {
            if (@mimeType == null)
                throw new ArgumentNullException("mimeType");
            using var __marshalled__mimeType = new NWaylandMarshalledString(@mimeType);
            WlArgument* __args = stackalloc WlArgument[] {
                __marshalled__mimeType
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
            base.Dispose(true);
        }

        /// <summary>
        /// Sets the actions that the source side client supports for thisoperation. This request may trigger wl_data_source.action andwl_data_offer.action events if the compositor needs to change theselected action.<br/><br/>
        /// The dnd_actions argument must contain only values expressed in thewl_data_device_manager.dnd_actions enum, otherwise it will resultin a protocol error.<br/><br/>
        /// This request must be made once only, and can only be made on sourcesused in drag-and-drop, so it must be performed beforewl_data_device.start_drag. Attempting to use the source other thanfor drag-and-drop will raise a protocol error.<br/><br/>
        /// </summary>
        public void SetActions(NWayland.Protocols.Wayland.WlDataDeviceManager.DndActionEnum @dndActions)
        {
            if (Version < 3)
                throw new InvalidOperationException("Request set_actions is only supported since version 3");
            WlArgument* __args = stackalloc WlArgument[] {
                (uint)@dndActions
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 2, __args);
        }

        public interface IEvents
        {
            /// <summary>
            /// Sent when a target accepts pointer_focus or motion events.  Ifa target does not accept any of the offered types, type is NULL.<br/><br/>
            /// Used for feedback during drag-and-drop.<br/><br/>
            /// </summary>
            void OnTarget(NWayland.Protocols.Wayland.WlDataSource eventSender, string? @mimeType);

            /// <summary>
            /// Request for data from the client.  Send the data as thespecified mime type over the passed file descriptor, thenclose it.<br/><br/>
            /// </summary>
            void OnSend(NWayland.Protocols.Wayland.WlDataSource eventSender, string @mimeType, int @fd);

            /// <summary>
            /// This data source is no longer valid. There are several reasons whythis could happen:<br/><br/>
            /// - The data source has been replaced by another data source.- The drag-and-drop operation was performed, but the drop destinationdid not accept any of the mime types offered throughwl_data_source.target.- The drag-and-drop operation was performed, but the drop destinationdid not select any of the actions present in the mask offered throughwl_data_source.action.- The drag-and-drop operation was performed but didn't happen over asurface.- The compositor cancelled the drag-and-drop operation (e.g. compositordependent timeouts to avoid stale drag-and-drop transfers).<br/><br/>
            /// The client should clean up and destroy this data source.<br/><br/>
            /// For objects of version 2 or older, wl_data_source.cancelled willonly be emitted if the data source was replaced by another datasource.<br/><br/>
            /// </summary>
            void OnCancelled(NWayland.Protocols.Wayland.WlDataSource eventSender);

            /// <summary>
            /// The user performed the drop action. This event does not indicateacceptance, wl_data_source.cancelled may still be emitted afterwardsif the drop destination does not accept any mime type.<br/><br/>
            /// However, this event might however not be received if the compositorcancelled the drag-and-drop operation before this event could happen.<br/><br/>
            /// Note that the data_source may still be used in the future and shouldnot be destroyed here.<br/><br/>
            /// </summary>
            void OnDndDropPerformed(NWayland.Protocols.Wayland.WlDataSource eventSender);

            /// <summary>
            /// The drop destination finished interoperating with this datasource, so the client is now free to destroy this data source andfree all associated data.<br/><br/>
            /// If the action used to perform the operation was "move", thesource can now delete the transferred data.<br/><br/>
            /// </summary>
            void OnDndFinished(NWayland.Protocols.Wayland.WlDataSource eventSender);

            /// <summary>
            /// This event indicates the action selected by the compositor aftermatching the source/destination side actions. Only one action (ornone) will be offered here.<br/><br/>
            /// This event can be emitted multiple times during the drag-and-dropoperation, mainly in response to destination side changes throughwl_data_offer.set_actions, and as the data device enters/leavessurfaces.<br/><br/>
            /// It is only possible to receive this event afterwl_data_source.dnd_drop_performed if the drag-and-drop operationended in an "ask" action, in which case the final wl_data_source.actionevent will happen immediately before wl_data_source.dnd_finished.<br/><br/>
            /// Compositors may also change the selected action on the fly, mainlyin response to keyboard modifier changes during the drag-and-dropoperation.<br/><br/>
            /// The most recent action received is always the valid one. The chosenaction may change alongside negotiation (e.g. an "ask" action can turninto a "move" operation), so the effects of the final action mustalways be applied in wl_data_offer.dnd_finished.<br/><br/>
            /// Clients can trigger cursor surface changes from this point, sothey reflect the current action.<br/><br/>
            /// </summary>
            void OnAction(NWayland.Protocols.Wayland.WlDataSource eventSender, NWayland.Protocols.Wayland.WlDataDeviceManager.DndActionEnum @dndAction);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnTarget(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr));
                    break;
                case 1:
                    Events?.OnSend(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr), arguments[1].Int32);
                    break;
                case 2:
                    Events?.OnCancelled(this);
                    break;
                case 3:
                    Events?.OnDndDropPerformed(this);
                    break;
                case 4:
                    Events?.OnDndFinished(this);
                    break;
                case 5:
                    Events?.OnAction(this, (NWayland.Protocols.Wayland.WlDataDeviceManager.DndActionEnum)arguments[0].UInt32);
                    break;
            }
        }

        public enum ErrorEnum
        {
            /// <summary>
            /// action mask contains invalid values<br/><br/>
            /// </summary>
            InvalidActionMask = 0,
            /// <summary>
            /// source doesn't accept this request<br/><br/>
            /// </summary>
            InvalidSource = 1
        }

        private class ProxyFactory : IBindFactory<WlDataSource>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlDataSource.WlInterface);
            }

            public WlDataSource Create(IntPtr handle, int version)
            {
                return new WlDataSource(handle, version);
            }
        }

        public static IBindFactory<WlDataSource> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "wl_data_source";
        public const int InterfaceVersion = 3;

        public WlDataSource(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// There is one wl_data_device per seat which can be obtainedfrom the global wl_data_device_manager singleton.<br/><br/>
    /// A wl_data_device provides access to inter-client data transfermechanisms such as copy-and-paste and drag-and-drop.<br/><br/>
    /// </summary>
    public sealed unsafe partial class WlDataDevice : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static WlDataDevice()
        {
            NWayland.Protocols.Wayland.WlDataDevice.WlInterface = new WlInterface("wl_data_device", 3, new WlMessage[] {
                new WlMessage("start_drag", "?oo?ou", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlDataSource.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface), null }),
                new WlMessage("set_selection", "?ou", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlDataSource.WlInterface), null }),
                new WlMessage("release", "2", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("data_offer", "n", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlDataOffer.WlInterface) }),
                new WlMessage("enter", "uoff?o", new WlInterface*[] { null, WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface), null, null, WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlDataOffer.WlInterface) }),
                new WlMessage("leave", "", new WlInterface*[] { }),
                new WlMessage("motion", "uff", new WlInterface*[] { null, null, null }),
                new WlMessage("drop", "", new WlInterface*[] { }),
                new WlMessage("selection", "?o", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlDataOffer.WlInterface) })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlDataDevice.WlInterface);
        }

        /// <summary>
        /// This request asks the compositor to start a drag-and-dropoperation on behalf of the client.<br/><br/>
        /// The source argument is the data source that provides the datafor the eventual data transfer. If source is NULL, enter, leaveand motion events are sent only to the client that initiated thedrag and the client is expected to handle the data passinginternally. If source is destroyed, the drag-and-drop session will becancelled.<br/><br/>
        /// The origin surface is the surface where the drag originates andthe client must have an active implicit grab that matches theserial.<br/><br/>
        /// The icon surface is an optional (can be NULL) surface thatprovides an icon to be moved around with the cursor.  Initially,the top-left corner of the icon surface is placed at the cursorhotspot, but subsequent wl_surface.attach request can move therelative position. Attach requests must be confirmed withwl_surface.commit as usual. The icon surface is given the role ofa drag-and-drop icon. If the icon surface already has another role,it raises a protocol error.<br/><br/>
        /// The current and pending input regions of the icon wl_surface arecleared, and wl_surface.set_input_region is ignored until thewl_surface is no longer used as the icon surface. When the useas an icon ends, the current and pending input regions becomeundefined, and the wl_surface is unmapped.<br/><br/>
        /// </summary>
        public void StartDrag(NWayland.Protocols.Wayland.WlDataSource? @source, NWayland.Protocols.Wayland.WlSurface @origin, NWayland.Protocols.Wayland.WlSurface? @icon, uint @serial)
        {
            if (@origin == null)
                throw new ArgumentNullException("origin");
            WlArgument* __args = stackalloc WlArgument[] {
                @source,
                @origin,
                @icon,
                @serial
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
        }

        /// <summary>
        /// This request asks the compositor to set the selectionto the data from the source on behalf of the client.<br/><br/>
        /// To unset the selection, set the source to NULL.<br/><br/>
        /// </summary>
        public void SetSelection(NWayland.Protocols.Wayland.WlDataSource? @source, uint @serial)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                @source,
                @serial
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
        }

        protected override void Dispose(bool disposing)
        {
            if (Version < 2)
                return;
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 2, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
            /// <summary>
            /// The data_offer event introduces a new wl_data_offer object,which will subsequently be used in either thedata_device.enter event (for drag-and-drop) or thedata_device.selection event (for selections).  Immediatelyfollowing the data_device.data_offer event, the new data_offerobject will send out data_offer.offer events to describe themime types it offers.<br/><br/>
            /// </summary>
            void OnDataOffer(NWayland.Protocols.Wayland.WlDataDevice eventSender, WlDataOffer @id);

            /// <summary>
            /// This event is sent when an active drag-and-drop pointer entersa surface owned by the client.  The position of the pointer atenter time is provided by the x and y arguments, in surface-localcoordinates.<br/><br/>
            /// </summary>
            void OnEnter(NWayland.Protocols.Wayland.WlDataDevice eventSender, uint @serial, NWayland.Protocols.Wayland.WlSurface @surface, WlFixed @x, WlFixed @y, NWayland.Protocols.Wayland.WlDataOffer? @id);

            /// <summary>
            /// This event is sent when the drag-and-drop pointer leaves thesurface and the session ends.  The client must destroy thewl_data_offer introduced at enter time at this point.<br/><br/>
            /// </summary>
            void OnLeave(NWayland.Protocols.Wayland.WlDataDevice eventSender);

            /// <summary>
            /// This event is sent when the drag-and-drop pointer moves withinthe currently focused surface. The new position of the pointeris provided by the x and y arguments, in surface-localcoordinates.<br/><br/>
            /// </summary>
            void OnMotion(NWayland.Protocols.Wayland.WlDataDevice eventSender, uint @time, WlFixed @x, WlFixed @y);

            /// <summary>
            /// The event is sent when a drag-and-drop operation is endedbecause the implicit grab is removed.<br/><br/>
            /// The drag-and-drop destination is expected to honor the last actionreceived through wl_data_offer.action, if the resulting action is"copy" or "move", the destination can still performwl_data_offer.receive requests, and is expected to end alltransfers with a wl_data_offer.finish request.<br/><br/>
            /// If the resulting action is "ask", the action will not be consideredfinal. The drag-and-drop destination is expected to perform one lastwl_data_offer.set_actions request, or wl_data_offer.destroy in orderto cancel the operation.<br/><br/>
            /// </summary>
            void OnDrop(NWayland.Protocols.Wayland.WlDataDevice eventSender);

            /// <summary>
            /// The selection event is sent out to notify the client of a newwl_data_offer for the selection for this device.  Thedata_device.data_offer and the data_offer.offer events aresent out immediately before this event to introduce the dataoffer object.  The selection event is sent to a clientimmediately before receiving keyboard focus and when a newselection is set while the client has keyboard focus.  Thedata_offer is valid until a new data_offer or NULL is receivedor until the client loses keyboard focus.  Switching surface withkeyboard focus within the same client doesn't mean a new selectionwill be sent.  The client must destroy the previous selectiondata_offer, if any, upon receiving this event.<br/><br/>
            /// </summary>
            void OnSelection(NWayland.Protocols.Wayland.WlDataDevice eventSender, NWayland.Protocols.Wayland.WlDataOffer? @id);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnDataOffer(this, new WlDataOffer(arguments[0].IntPtr, Version));
                    break;
                case 1:
                    Events?.OnEnter(this, arguments[0].UInt32, WlProxy.FromNative<NWayland.Protocols.Wayland.WlSurface>(arguments[1].IntPtr), arguments[2].WlFixed, arguments[3].WlFixed, WlProxy.FromNative<NWayland.Protocols.Wayland.WlDataOffer>(arguments[4].IntPtr));
                    break;
                case 2:
                    Events?.OnLeave(this);
                    break;
                case 3:
                    Events?.OnMotion(this, arguments[0].UInt32, arguments[1].WlFixed, arguments[2].WlFixed);
                    break;
                case 4:
                    Events?.OnDrop(this);
                    break;
                case 5:
                    Events?.OnSelection(this, WlProxy.FromNative<NWayland.Protocols.Wayland.WlDataOffer>(arguments[0].IntPtr));
                    break;
            }
        }

        public enum ErrorEnum
        {
            /// <summary>
            /// given wl_surface has another role<br/><br/>
            /// </summary>
            Role = 0
        }

        private class ProxyFactory : IBindFactory<WlDataDevice>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlDataDevice.WlInterface);
            }

            public WlDataDevice Create(IntPtr handle, int version)
            {
                return new WlDataDevice(handle, version);
            }
        }

        public static IBindFactory<WlDataDevice> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "wl_data_device";
        public const int InterfaceVersion = 3;

        public WlDataDevice(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// The wl_data_device_manager is a singleton global object thatprovides access to inter-client data transfer mechanisms such ascopy-and-paste and drag-and-drop.  These mechanisms are tied toa wl_seat and this interface lets a client get a wl_data_devicecorresponding to a wl_seat.<br/><br/>
    /// Depending on the version bound, the objects created from the boundwl_data_device_manager object will have different requirements forfunctioning properly. See wl_data_source.set_actions,wl_data_offer.accept and wl_data_offer.finish for details.<br/><br/>
    /// </summary>
    public sealed unsafe partial class WlDataDeviceManager : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static WlDataDeviceManager()
        {
            NWayland.Protocols.Wayland.WlDataDeviceManager.WlInterface = new WlInterface("wl_data_device_manager", 3, new WlMessage[] {
                new WlMessage("create_data_source", "n", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlDataSource.WlInterface) }),
                new WlMessage("get_data_device", "no", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlDataDevice.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSeat.WlInterface) })
            }, new WlMessage[] { });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlDataDeviceManager.WlInterface);
        }

        /// <summary>
        /// Create a new data source.<br/><br/>
        /// </summary>
        public NWayland.Protocols.Wayland.WlDataSource CreateDataSource()
        {
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 0, __args, ref NWayland.Protocols.Wayland.WlDataSource.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.Wayland.WlDataSource(__ret, Version);
        }

        /// <summary>
        /// Create a new data device for a given seat.<br/><br/>
        /// </summary>
        public NWayland.Protocols.Wayland.WlDataDevice GetDataDevice(NWayland.Protocols.Wayland.WlSeat @seat)
        {
            if (@seat == null)
                throw new ArgumentNullException("seat");
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId,
                @seat
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 1, __args, ref NWayland.Protocols.Wayland.WlDataDevice.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.Wayland.WlDataDevice(__ret, Version);
        }

        public interface IEvents
        {
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
        }

        /// <summary>
        /// This is a bitmask of the available/preferred actions in adrag-and-drop operation.<br/><br/>
        /// In the compositor, the selected action is a result of matching theactions offered by the source and destination sides.  "action" eventswith a "none" action will be sent to both source and destination ifthere is no match. All further checks will effectively happen on(source actions  destination actions).<br/><br/>
        /// In addition, compositors may also pick different actions inreaction to key modifiers being pressed. One common design thatis used in major toolkits (and the behavior recommended forcompositors) is:<br/><br/>
        /// - If no modifiers are pressed, the first match (in bit order)will be used.- Pressing Shift selects "move", if enabled in the mask.- Pressing Control selects "copy", if enabled in the mask.<br/><br/>
        /// Behavior beyond that is considered implementation-dependent.Compositors may for example bind other modifiers (like Alt/Meta)or drags initiated with other buttons than BTN_LEFT to specificactions (e.g. "ask").<br/><br/>
        /// </summary>
        [Flags]
        public enum DndActionEnum
        {
            /// <summary>
            /// no action<br/><br/>
            /// </summary>
            None = 0,
            /// <summary>
            /// copy action<br/><br/>
            /// </summary>
            Copy = 1,
            /// <summary>
            /// move action<br/><br/>
            /// </summary>
            Move = 2,
            /// <summary>
            /// ask action<br/><br/>
            /// </summary>
            Ask = 4
        }

        private class ProxyFactory : IBindFactory<WlDataDeviceManager>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlDataDeviceManager.WlInterface);
            }

            public WlDataDeviceManager Create(IntPtr handle, int version)
            {
                return new WlDataDeviceManager(handle, version);
            }
        }

        public static IBindFactory<WlDataDeviceManager> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "wl_data_device_manager";
        public const int InterfaceVersion = 3;

        public WlDataDeviceManager(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// This interface is implemented by servers that providedesktop-style user interfaces.<br/><br/>
    /// It allows clients to associate a wl_shell_surface witha basic surface.<br/><br/>
    /// Note! This protocol is deprecated and not intended for production use.For desktop-style user interfaces, use xdg_shell. Compositors and clientsshould not implement this interface.<br/><br/>
    /// </summary>
    public sealed unsafe partial class WlShell : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static WlShell()
        {
            NWayland.Protocols.Wayland.WlShell.WlInterface = new WlInterface("wl_shell", 1, new WlMessage[] {
                new WlMessage("get_shell_surface", "no", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlShellSurface.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface) })
            }, new WlMessage[] { });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlShell.WlInterface);
        }

        /// <summary>
        /// Create a shell surface for an existing surface. This givesthe wl_surface the role of a shell surface. If the wl_surfacealready has another role, it raises a protocol error.<br/><br/>
        /// Only one shell surface can be associated with a given surface.<br/><br/>
        /// </summary>
        public NWayland.Protocols.Wayland.WlShellSurface GetShellSurface(NWayland.Protocols.Wayland.WlSurface @surface)
        {
            if (@surface == null)
                throw new ArgumentNullException("surface");
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId,
                @surface
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 0, __args, ref NWayland.Protocols.Wayland.WlShellSurface.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.Wayland.WlShellSurface(__ret, Version);
        }

        public interface IEvents
        {
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
        }

        public enum ErrorEnum
        {
            /// <summary>
            /// given wl_surface has another role<br/><br/>
            /// </summary>
            Role = 0
        }

        private class ProxyFactory : IBindFactory<WlShell>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlShell.WlInterface);
            }

            public WlShell Create(IntPtr handle, int version)
            {
                return new WlShell(handle, version);
            }
        }

        public static IBindFactory<WlShell> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "wl_shell";
        public const int InterfaceVersion = 1;

        public WlShell(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// An interface that may be implemented by a wl_surface, forimplementations that provide a desktop-style user interface.<br/><br/>
    /// It provides requests to treat surfaces like toplevel, fullscreenor popup windows, move, resize or maximize them, associatemetadata like title and class, etc.<br/><br/>
    /// On the server side the object is automatically destroyed whenthe related wl_surface is destroyed. On the client side,wl_shell_surface_destroy() must be called before destroyingthe wl_surface object.<br/><br/>
    /// </summary>
    public sealed unsafe partial class WlShellSurface : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static WlShellSurface()
        {
            NWayland.Protocols.Wayland.WlShellSurface.WlInterface = new WlInterface("wl_shell_surface", 1, new WlMessage[] {
                new WlMessage("pong", "u", new WlInterface*[] { null }),
                new WlMessage("move", "ou", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSeat.WlInterface), null }),
                new WlMessage("resize", "ouu", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSeat.WlInterface), null, null }),
                new WlMessage("set_toplevel", "", new WlInterface*[] { }),
                new WlMessage("set_transient", "oiiu", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface), null, null, null }),
                new WlMessage("set_fullscreen", "uu?o", new WlInterface*[] { null, null, WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlOutput.WlInterface) }),
                new WlMessage("set_popup", "ouoiiu", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSeat.WlInterface), null, WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface), null, null, null }),
                new WlMessage("set_maximized", "?o", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlOutput.WlInterface) }),
                new WlMessage("set_title", "s", new WlInterface*[] { null }),
                new WlMessage("set_class", "s", new WlInterface*[] { null })
            }, new WlMessage[] {
                new WlMessage("ping", "u", new WlInterface*[] { null }),
                new WlMessage("configure", "uii", new WlInterface*[] { null, null, null }),
                new WlMessage("popup_done", "", new WlInterface*[] { })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlShellSurface.WlInterface);
        }

        /// <summary>
        /// A client must respond to a ping event with a pong request orthe client may be deemed unresponsive.<br/><br/>
        /// </summary>
        public void Pong(uint @serial)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                @serial
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
        }

        /// <summary>
        /// Start a pointer-driven move of the surface.<br/><br/>
        /// This request must be used in response to a button press event.The server may ignore move requests depending on the state ofthe surface (e.g. fullscreen or maximized).<br/><br/>
        /// </summary>
        public void Move(NWayland.Protocols.Wayland.WlSeat @seat, uint @serial)
        {
            if (@seat == null)
                throw new ArgumentNullException("seat");
            WlArgument* __args = stackalloc WlArgument[] {
                @seat,
                @serial
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
        }

        /// <summary>
        /// Start a pointer-driven resizing of the surface.<br/><br/>
        /// This request must be used in response to a button press event.The server may ignore resize requests depending on the state ofthe surface (e.g. fullscreen or maximized).<br/><br/>
        /// </summary>
        public void Resize(NWayland.Protocols.Wayland.WlSeat @seat, uint @serial, ResizeEnum @edges)
        {
            if (@seat == null)
                throw new ArgumentNullException("seat");
            WlArgument* __args = stackalloc WlArgument[] {
                @seat,
                @serial,
                (uint)@edges
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 2, __args);
        }

        /// <summary>
        /// Map the surface as a toplevel surface.<br/><br/>
        /// A toplevel surface is not fullscreen, maximized or transient.<br/><br/>
        /// </summary>
        public void SetToplevel()
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 3, __args);
        }

        /// <summary>
        /// Map the surface relative to an existing surface.<br/><br/>
        /// The x and y arguments specify the location of the upper leftcorner of the surface relative to the upper left corner of theparent surface, in surface-local coordinates.<br/><br/>
        /// The flags argument controls details of the transient behaviour.<br/><br/>
        /// </summary>
        public void SetTransient(NWayland.Protocols.Wayland.WlSurface @parent, int @x, int @y, TransientEnum @flags)
        {
            if (@parent == null)
                throw new ArgumentNullException("parent");
            WlArgument* __args = stackalloc WlArgument[] {
                @parent,
                @x,
                @y,
                (uint)@flags
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 4, __args);
        }

        /// <summary>
        /// Map the surface as a fullscreen surface.<br/><br/>
        /// If an output parameter is given then the surface will be madefullscreen on that output. If the client does not specify theoutput then the compositor will apply its policy - usuallychoosing the output on which the surface has the biggest surfacearea.<br/><br/>
        /// The client may specify a method to resolve a size conflictbetween the output size and the surface size - this is providedthrough the method parameter.<br/><br/>
        /// The framerate parameter is used only when the method is setto "driver", to indicate the preferred framerate. A value of 0indicates that the client does not care about framerate.  Theframerate is specified in mHz, that is framerate of 60000 is 60Hz.<br/><br/>
        /// A method of "scale" or "driver" implies a scaling operation ofthe surface, either via a direct scaling operation or a change ofthe output mode. This will override any kind of output scaling, sothat mapping a surface with a buffer size equal to the mode canfill the screen independent of buffer_scale.<br/><br/>
        /// A method of "fill" means we don't scale up the buffer, howeverany output scale is applied. This means that you may run intoan edge case where the application maps a buffer with the samesize of the output mode but buffer_scale 1 (thus making asurface larger than the output). In this case it is allowed todownscale the results to fit the screen.<br/><br/>
        /// The compositor must reply to this request with a configure eventwith the dimensions for the output on which the surface willbe made fullscreen.<br/><br/>
        /// </summary>
        public void SetFullscreen(FullscreenMethodEnum @method, uint @framerate, NWayland.Protocols.Wayland.WlOutput? @output)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                (uint)@method,
                @framerate,
                @output
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 5, __args);
        }

        /// <summary>
        /// Map the surface as a popup.<br/><br/>
        /// A popup surface is a transient surface with an added pointergrab.<br/><br/>
        /// An existing implicit grab will be changed to owner-events mode,and the popup grab will continue after the implicit grab ends(i.e. releasing the mouse button does not cause the popup tobe unmapped).<br/><br/>
        /// The popup grab continues until the window is destroyed or amouse button is pressed in any other client's window. A clickin any of the client's surfaces is reported as normal, however,clicks in other clients' surfaces will be discarded and triggerthe callback.<br/><br/>
        /// The x and y arguments specify the location of the upper leftcorner of the surface relative to the upper left corner of theparent surface, in surface-local coordinates.<br/><br/>
        /// </summary>
        public void SetPopup(NWayland.Protocols.Wayland.WlSeat @seat, uint @serial, NWayland.Protocols.Wayland.WlSurface @parent, int @x, int @y, TransientEnum @flags)
        {
            if (@parent == null)
                throw new ArgumentNullException("parent");
            if (@seat == null)
                throw new ArgumentNullException("seat");
            WlArgument* __args = stackalloc WlArgument[] {
                @seat,
                @serial,
                @parent,
                @x,
                @y,
                (uint)@flags
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 6, __args);
        }

        /// <summary>
        /// Map the surface as a maximized surface.<br/><br/>
        /// If an output parameter is given then the surface will bemaximized on that output. If the client does not specify theoutput then the compositor will apply its policy - usuallychoosing the output on which the surface has the biggest surfacearea.<br/><br/>
        /// The compositor will reply with a configure event tellingthe expected new surface size. The operation is completedon the next buffer attach to this surface.<br/><br/>
        /// A maximized surface typically fills the entire output it isbound to, except for desktop elements such as panels. This isthe main difference between a maximized shell surface and afullscreen shell surface.<br/><br/>
        /// The details depend on the compositor implementation.<br/><br/>
        /// </summary>
        public void SetMaximized(NWayland.Protocols.Wayland.WlOutput? @output)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                @output
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 7, __args);
        }

        /// <summary>
        /// Set a short title for the surface.<br/><br/>
        /// This string may be used to identify the surface in a task bar,window list, or other user interface elements provided by thecompositor.<br/><br/>
        /// The string must be encoded in UTF-8.<br/><br/>
        /// </summary>
        public void SetTitle(string @title)
        {
            if (@title == null)
                throw new ArgumentNullException("title");
            using var __marshalled__title = new NWaylandMarshalledString(@title);
            WlArgument* __args = stackalloc WlArgument[] {
                __marshalled__title
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 8, __args);
        }

        /// <summary>
        /// Set a class for the surface.<br/><br/>
        /// The surface class identifies the general class of applicationsto which the surface belongs. A common convention is to use thefile name (or the full path if it is a non-standard location) ofthe application's .desktop file as the class.<br/><br/>
        /// </summary>
        public void SetClass(string @class)
        {
            if (@class == null)
                throw new ArgumentNullException("class");
            using var __marshalled__class = new NWaylandMarshalledString(@class);
            WlArgument* __args = stackalloc WlArgument[] {
                __marshalled__class
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 9, __args);
        }

        public interface IEvents
        {
            /// <summary>
            /// Ping a client to check if it is receiving events and sendingrequests. A client is expected to reply with a pong request.<br/><br/>
            /// </summary>
            void OnPing(NWayland.Protocols.Wayland.WlShellSurface eventSender, uint @serial);

            /// <summary>
            /// The configure event asks the client to resize its surface.<br/><br/>
            /// The size is a hint, in the sense that the client is free toignore it if it doesn't resize, pick a smaller size (tosatisfy aspect ratio or resize in steps of NxM pixels).<br/><br/>
            /// The edges parameter provides a hint about how the surfacewas resized. The client may use this information to decidehow to adjust its content to the new size (e.g. a scrollingarea might adjust its content position to leave the viewablecontent unmoved).<br/><br/>
            /// The client is free to dismiss all but the last configureevent it received.<br/><br/>
            /// The width and height arguments specify the size of the windowin surface-local coordinates.<br/><br/>
            /// </summary>
            void OnConfigure(NWayland.Protocols.Wayland.WlShellSurface eventSender, ResizeEnum @edges, int @width, int @height);

            /// <summary>
            /// The popup_done event is sent out when a popup grab is broken,that is, when the user clicks a surface that doesn't belongto the client owning the popup surface.<br/><br/>
            /// </summary>
            void OnPopupDone(NWayland.Protocols.Wayland.WlShellSurface eventSender);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnPing(this, arguments[0].UInt32);
                    break;
                case 1:
                    Events?.OnConfigure(this, (ResizeEnum)arguments[0].UInt32, arguments[1].Int32, arguments[2].Int32);
                    break;
                case 2:
                    Events?.OnPopupDone(this);
                    break;
            }
        }

        /// <summary>
        /// These values are used to indicate which edge of a surfaceis being dragged in a resize operation. The server mayuse this information to adapt its behavior, e.g. choosean appropriate cursor image.<br/><br/>
        /// </summary>
        [Flags]
        public enum ResizeEnum
        {
            /// <summary>
            /// no edge<br/><br/>
            /// </summary>
            None = 0,
            /// <summary>
            /// top edge<br/><br/>
            /// </summary>
            Top = 1,
            /// <summary>
            /// bottom edge<br/><br/>
            /// </summary>
            Bottom = 2,
            /// <summary>
            /// left edge<br/><br/>
            /// </summary>
            Left = 4,
            /// <summary>
            /// top and left edges<br/><br/>
            /// </summary>
            TopLeft = 5,
            /// <summary>
            /// bottom and left edges<br/><br/>
            /// </summary>
            BottomLeft = 6,
            /// <summary>
            /// right edge<br/><br/>
            /// </summary>
            Right = 8,
            /// <summary>
            /// top and right edges<br/><br/>
            /// </summary>
            TopRight = 9,
            /// <summary>
            /// bottom and right edges<br/><br/>
            /// </summary>
            BottomRight = 10
        }

        /// <summary>
        /// These flags specify details of the expected behaviourof transient surfaces. Used in the set_transient request.<br/><br/>
        /// </summary>
        [Flags]
        public enum TransientEnum
        {
            /// <summary>
            /// do not set keyboard focus<br/><br/>
            /// </summary>
            Inactive = 0x1
        }

        /// <summary>
        /// Hints to indicate to the compositor how to deal with a conflictbetween the dimensions of the surface and the dimensions of theoutput. The compositor is free to ignore this parameter.<br/><br/>
        /// </summary>
        public enum FullscreenMethodEnum
        {
            /// <summary>
            /// no preference, apply default policy<br/><br/>
            /// </summary>
            Default = 0,
            /// <summary>
            /// scale, preserve the surface's aspect ratio and center on output<br/><br/>
            /// </summary>
            Scale = 1,
            /// <summary>
            /// switch output mode to the smallest mode that can fit the surface, add black borders to compensate size mismatch<br/><br/>
            /// </summary>
            Driver = 2,
            /// <summary>
            /// no upscaling, center on output and add black borders to compensate size mismatch<br/><br/>
            /// </summary>
            Fill = 3
        }

        private class ProxyFactory : IBindFactory<WlShellSurface>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlShellSurface.WlInterface);
            }

            public WlShellSurface Create(IntPtr handle, int version)
            {
                return new WlShellSurface(handle, version);
            }
        }

        public static IBindFactory<WlShellSurface> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "wl_shell_surface";
        public const int InterfaceVersion = 1;

        public WlShellSurface(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// A surface is a rectangular area that may be displayed on zeroor more outputs, and shown any number of times at the compositor'sdiscretion. They can present wl_buffers, receive user input, anddefine a local coordinate system.<br/><br/>
    /// The size of a surface (and relative positions on it) is describedin surface-local coordinates, which may differ from the buffercoordinates of the pixel content, in case a buffer_transformor a buffer_scale is used.<br/><br/>
    /// A surface without a "role" is fairly useless: a compositor doesnot know where, when or how to present it. The role is thepurpose of a wl_surface. Examples of roles are a cursor for apointer (as set by wl_pointer.set_cursor), a drag icon(wl_data_device.start_drag), a sub-surface(wl_subcompositor.get_subsurface), and a window as defined by ashell protocol (e.g. wl_shell.get_shell_surface).<br/><br/>
    /// A surface can have only one role at a time. Initially awl_surface does not have a role. Once a wl_surface is given arole, it is set permanently for the whole lifetime of thewl_surface object. Giving the current role again is allowed,unless explicitly forbidden by the relevant interfacespecification.<br/><br/>
    /// Surface roles are given by requests in other interfaces such aswl_pointer.set_cursor. The request should explicitly mentionthat this request gives a role to a wl_surface. Often, thisrequest also creates a new protocol object that represents therole and adds additional functionality to wl_surface. When aclient wants to destroy a wl_surface, they must destroy this 'roleobject' before the wl_surface.<br/><br/>
    /// Destroying the role object does not remove the role from thewl_surface, but it may stop the wl_surface from "playing the role".For instance, if a wl_subsurface object is destroyed, the wl_surfaceit was created for will be unmapped and forget its position andz-order. It is allowed to create a wl_subsurface for the samewl_surface again, but it is not allowed to use the wl_surface asa cursor (cursor is a different role than sub-surface, and roleswitching is not allowed).<br/><br/>
    /// </summary>
    public sealed unsafe partial class WlSurface : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static WlSurface()
        {
            NWayland.Protocols.Wayland.WlSurface.WlInterface = new WlInterface("wl_surface", 5, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { }),
                new WlMessage("attach", "?oii", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlBuffer.WlInterface), null, null }),
                new WlMessage("damage", "iiii", new WlInterface*[] { null, null, null, null }),
                new WlMessage("frame", "n", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlCallback.WlInterface) }),
                new WlMessage("set_opaque_region", "?o", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlRegion.WlInterface) }),
                new WlMessage("set_input_region", "?o", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlRegion.WlInterface) }),
                new WlMessage("commit", "", new WlInterface*[] { }),
                new WlMessage("set_buffer_transform", "2i", new WlInterface*[] { null }),
                new WlMessage("set_buffer_scale", "3i", new WlInterface*[] { null }),
                new WlMessage("damage_buffer", "4iiii", new WlInterface*[] { null, null, null, null }),
                new WlMessage("offset", "5ii", new WlInterface*[] { null, null })
            }, new WlMessage[] {
                new WlMessage("enter", "o", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlOutput.WlInterface) }),
                new WlMessage("leave", "o", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlOutput.WlInterface) })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        /// <summary>
        /// Set a buffer as the content of this surface.<br/><br/>
        /// The new size of the surface is calculated based on the buffersize transformed by the inverse buffer_transform and theinverse buffer_scale. This means that at commit time the suppliedbuffer size must be an integer multiple of the buffer_scale. Ifthat's not the case, an invalid_size error is sent.<br/><br/>
        /// The x and y arguments specify the location of the new pendingbuffer's upper left corner, relative to the current buffer's upperleft corner, in surface-local coordinates. In other words, thex and y, combined with the new surface size define in whichdirections the surface's size changes. Setting anything other than 0as x and y arguments is discouraged, and should instead be replacedwith using the separate wl_surface.offset request.<br/><br/>
        /// When the bound wl_surface version is 5 or higher, passing anynon-zero x or y is a protocol violation, and will result in an'invalid_offset' error being raised. To achieve equivalent semantics,use wl_surface.offset.<br/><br/>
        /// Surface contents are double-buffered state, see wl_surface.commit.<br/><br/>
        /// The initial surface contents are void; there is no content.wl_surface.attach assigns the given wl_buffer as the pendingwl_buffer. wl_surface.commit makes the pending wl_buffer the newsurface contents, and the size of the surface becomes the sizecalculated from the wl_buffer, as described above. After commit,there is no pending buffer until the next attach.<br/><br/>
        /// Committing a pending wl_buffer allows the compositor to read thepixels in the wl_buffer. The compositor may access the pixels atany time after the wl_surface.commit request. When the compositorwill not access the pixels anymore, it will send thewl_buffer.release event. Only after receiving wl_buffer.release,the client may reuse the wl_buffer. A wl_buffer that has beenattached and then replaced by another attach instead of committedwill not receive a release event, and is not used by thecompositor.<br/><br/>
        /// If a pending wl_buffer has been committed to more than one wl_surface,the delivery of wl_buffer.release events becomes undefined. A wellbehaved client should not rely on wl_buffer.release events in thiscase. Alternatively, a client could create multiple wl_buffer objectsfrom the same backing storage or use wp_linux_buffer_release.<br/><br/>
        /// Destroying the wl_buffer after wl_buffer.release does not changethe surface contents. Destroying the wl_buffer before wl_buffer.releaseis allowed as long as the underlying buffer storage isn't re-used (thiscan happen e.g. on client process termination). However, if the clientdestroys the wl_buffer before receiving the wl_buffer.release event andmutates the underlying buffer storage, the surface contents becomeundefined immediately.<br/><br/>
        /// If wl_surface.attach is sent with a NULL wl_buffer, thefollowing wl_surface.commit will remove the surface content.<br/><br/>
        /// </summary>
        public void Attach(NWayland.Protocols.Wayland.WlBuffer? @buffer, int @x, int @y)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                @buffer,
                @x,
                @y
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
        }

        /// <summary>
        /// This request is used to describe the regions where the pendingbuffer is different from the current surface contents, and wherethe surface therefore needs to be repainted. The compositorignores the parts of the damage that fall outside of the surface.<br/><br/>
        /// Damage is double-buffered state, see wl_surface.commit.<br/><br/>
        /// The damage rectangle is specified in surface-local coordinates,where x and y specify the upper left corner of the damage rectangle.<br/><br/>
        /// The initial value for pending damage is empty: no damage.wl_surface.damage adds pending damage: the new pending damageis the union of old pending damage and the given rectangle.<br/><br/>
        /// wl_surface.commit assigns pending damage as the current damage,and clears pending damage. The server will clear the currentdamage as it repaints the surface.<br/><br/>
        /// Note! New clients should not use this request. Instead damage can beposted with wl_surface.damage_buffer which uses buffer coordinatesinstead of surface coordinates.<br/><br/>
        /// </summary>
        public void Damage(int @x, int @y, int @width, int @height)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                @x,
                @y,
                @width,
                @height
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 2, __args);
        }

        /// <summary>
        /// Request a notification when it is a good time to start drawing a newframe, by creating a frame callback. This is useful for throttlingredrawing operations, and driving animations.<br/><br/>
        /// When a client is animating on a wl_surface, it can use the 'frame'request to get notified when it is a good time to draw and commit thenext frame of animation. If the client commits an update earlier thanthat, it is likely that some updates will not make it to the display,and the client is wasting resources by drawing too often.<br/><br/>
        /// The frame request will take effect on the next wl_surface.commit.The notification will only be posted for one frame unlessrequested again. For a wl_surface, the notifications are posted inthe order the frame requests were committed.<br/><br/>
        /// The server must send the notifications so that a clientwill not send excessive updates, while still allowingthe highest possible update rate for clients that wait for the replybefore drawing again. The server should give some time for the clientto draw and commit after sending the frame callback events to let ithit the next output refresh.<br/><br/>
        /// A server should avoid signaling the frame callbacks if thesurface is not visible in any way, e.g. the surface is off-screen,or completely obscured by other opaque surfaces.<br/><br/>
        /// The object returned by this request will be destroyed by thecompositor after the callback is fired and as such the client must notattempt to use it after that point.<br/><br/>
        /// The callback_data passed in the callback is the current time, inmilliseconds, with an undefined base.<br/><br/>
        /// </summary>
        public NWayland.Protocols.Wayland.WlCallback Frame()
        {
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 3, __args, ref NWayland.Protocols.Wayland.WlCallback.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.Wayland.WlCallback(__ret, Version);
        }

        /// <summary>
        /// This request sets the region of the surface that containsopaque content.<br/><br/>
        /// The opaque region is an optimization hint for the compositorthat lets it optimize the redrawing of content behind opaqueregions.  Setting an opaque region is not required for correctbehaviour, but marking transparent content as opaque will resultin repaint artifacts.<br/><br/>
        /// The opaque region is specified in surface-local coordinates.<br/><br/>
        /// The compositor ignores the parts of the opaque region that falloutside of the surface.<br/><br/>
        /// Opaque region is double-buffered state, see wl_surface.commit.<br/><br/>
        /// wl_surface.set_opaque_region changes the pending opaque region.wl_surface.commit copies the pending region to the current region.Otherwise, the pending and current regions are never changed.<br/><br/>
        /// The initial value for an opaque region is empty. Setting the pendingopaque region has copy semantics, and the wl_region object can bedestroyed immediately. A NULL wl_region causes the pending opaqueregion to be set to empty.<br/><br/>
        /// </summary>
        public void SetOpaqueRegion(NWayland.Protocols.Wayland.WlRegion? @region)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                @region
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 4, __args);
        }

        /// <summary>
        /// This request sets the region of the surface that can receivepointer and touch events.<br/><br/>
        /// Input events happening outside of this region will try the nextsurface in the server surface stack. The compositor ignores theparts of the input region that fall outside of the surface.<br/><br/>
        /// The input region is specified in surface-local coordinates.<br/><br/>
        /// Input region is double-buffered state, see wl_surface.commit.<br/><br/>
        /// wl_surface.set_input_region changes the pending input region.wl_surface.commit copies the pending region to the current region.Otherwise the pending and current regions are never changed,except cursor and icon surfaces are special cases, seewl_pointer.set_cursor and wl_data_device.start_drag.<br/><br/>
        /// The initial value for an input region is infinite. That means thewhole surface will accept input. Setting the pending input regionhas copy semantics, and the wl_region object can be destroyedimmediately. A NULL wl_region causes the input region to be setto infinite.<br/><br/>
        /// </summary>
        public void SetInputRegion(NWayland.Protocols.Wayland.WlRegion? @region)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                @region
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 5, __args);
        }

        /// <summary>
        /// Surface state (input, opaque, and damage regions, attached buffers,etc.) is double-buffered. Protocol requests modify the pending state,as opposed to the current state in use by the compositor. A commitrequest atomically applies all pending state, replacing the currentstate. After commit, the new pending state is as documented for eachrelated request.<br/><br/>
        /// On commit, a pending wl_buffer is applied first, and all other statesecond. This means that all coordinates in double-buffered state arerelative to the new wl_buffer coming into use, except forwl_surface.attach itself. If there is no pending wl_buffer, thecoordinates are relative to the current surface contents.<br/><br/>
        /// All requests that need a commit to become effective are documentedto affect double-buffered state.<br/><br/>
        /// Other interfaces may add further double-buffered surface state.<br/><br/>
        /// </summary>
        public void Commit()
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 6, __args);
        }

        /// <summary>
        /// This request sets an optional transformation on how the compositorinterprets the contents of the buffer attached to the surface. Theaccepted values for the transform parameter are the values forwl_output.transform.<br/><br/>
        /// Buffer transform is double-buffered state, see wl_surface.commit.<br/><br/>
        /// A newly created surface has its buffer transformation set to normal.<br/><br/>
        /// wl_surface.set_buffer_transform changes the pending buffertransformation. wl_surface.commit copies the pending buffertransformation to the current one. Otherwise, the pending and currentvalues are never changed.<br/><br/>
        /// The purpose of this request is to allow clients to render contentaccording to the output transform, thus permitting the compositor touse certain optimizations even if the display is rotated. Usinghardware overlays and scanning out a client buffer for fullscreensurfaces are examples of such optimizations. Those optimizations arehighly dependent on the compositor implementation, so the use of thisrequest should be considered on a case-by-case basis.<br/><br/>
        /// Note that if the transform value includes 90 or 270 degree rotation,the width of the buffer will become the surface height and the heightof the buffer will become the surface width.<br/><br/>
        /// If transform is not one of the values from thewl_output.transform enum the invalid_transform protocol erroris raised.<br/><br/>
        /// </summary>
        public void SetBufferTransform(NWayland.Protocols.Wayland.WlOutput.TransformEnum @transform)
        {
            if (Version < 2)
                throw new InvalidOperationException("Request set_buffer_transform is only supported since version 2");
            WlArgument* __args = stackalloc WlArgument[] {
                (int)@transform
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 7, __args);
        }

        /// <summary>
        /// This request sets an optional scaling factor on how the compositorinterprets the contents of the buffer attached to the window.<br/><br/>
        /// Buffer scale is double-buffered state, see wl_surface.commit.<br/><br/>
        /// A newly created surface has its buffer scale set to 1.<br/><br/>
        /// wl_surface.set_buffer_scale changes the pending buffer scale.wl_surface.commit copies the pending buffer scale to the current one.Otherwise, the pending and current values are never changed.<br/><br/>
        /// The purpose of this request is to allow clients to supply higherresolution buffer data for use on high resolution outputs. It isintended that you pick the same buffer scale as the scale of theoutput that the surface is displayed on. This means the compositorcan avoid scaling when rendering the surface on that output.<br/><br/>
        /// Note that if the scale is larger than 1, then you have to attacha buffer that is larger (by a factor of scale in each dimension)than the desired surface size.<br/><br/>
        /// If scale is not positive the invalid_scale protocol error israised.<br/><br/>
        /// </summary>
        public void SetBufferScale(int @scale)
        {
            if (Version < 3)
                throw new InvalidOperationException("Request set_buffer_scale is only supported since version 3");
            WlArgument* __args = stackalloc WlArgument[] {
                @scale
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 8, __args);
        }

        /// <summary>
        /// This request is used to describe the regions where the pendingbuffer is different from the current surface contents, and wherethe surface therefore needs to be repainted. The compositorignores the parts of the damage that fall outside of the surface.<br/><br/>
        /// Damage is double-buffered state, see wl_surface.commit.<br/><br/>
        /// The damage rectangle is specified in buffer coordinates,where x and y specify the upper left corner of the damage rectangle.<br/><br/>
        /// The initial value for pending damage is empty: no damage.wl_surface.damage_buffer adds pending damage: the new pendingdamage is the union of old pending damage and the given rectangle.<br/><br/>
        /// wl_surface.commit assigns pending damage as the current damage,and clears pending damage. The server will clear the currentdamage as it repaints the surface.<br/><br/>
        /// This request differs from wl_surface.damage in only one way - ittakes damage in buffer coordinates instead of surface-localcoordinates. While this generally is more intuitive than surfacecoordinates, it is especially desirable when using wp_viewportor when a drawing library (like EGL) is unaware of buffer scaleand buffer transform.<br/><br/>
        /// Note: Because buffer transformation changes and damage requests maybe interleaved in the protocol stream, it is impossible to determinethe actual mapping between surface and buffer damage untilwl_surface.commit time. Therefore, compositors wishing to take bothkinds of damage into account will have to accumulate damage from thetwo requests separately and only transform from one to the otherafter receiving the wl_surface.commit.<br/><br/>
        /// </summary>
        public void DamageBuffer(int @x, int @y, int @width, int @height)
        {
            if (Version < 4)
                throw new InvalidOperationException("Request damage_buffer is only supported since version 4");
            WlArgument* __args = stackalloc WlArgument[] {
                @x,
                @y,
                @width,
                @height
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 9, __args);
        }

        /// <summary>
        /// The x and y arguments specify the location of the new pendingbuffer's upper left corner, relative to the current buffer's upperleft corner, in surface-local coordinates. In other words, thex and y, combined with the new surface size define in whichdirections the surface's size changes.<br/><br/>
        /// Surface location offset is double-buffered state, seewl_surface.commit.<br/><br/>
        /// This request is semantically equivalent to and the replaces the x and yarguments in the wl_surface.attach request in wl_surface versions priorto 5. See wl_surface.attach for details.<br/><br/>
        /// </summary>
        public void Offset(int @x, int @y)
        {
            if (Version < 5)
                throw new InvalidOperationException("Request offset is only supported since version 5");
            WlArgument* __args = stackalloc WlArgument[] {
                @x,
                @y
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 10, __args);
        }

        public interface IEvents
        {
            /// <summary>
            /// This is emitted whenever a surface's creation, movement, or resizingresults in some part of it being within the scanout region of anoutput.<br/><br/>
            /// Note that a surface may be overlapping with zero or more outputs.<br/><br/>
            /// </summary>
            void OnEnter(NWayland.Protocols.Wayland.WlSurface eventSender, NWayland.Protocols.Wayland.WlOutput @output);

            /// <summary>
            /// This is emitted whenever a surface's creation, movement, or resizingresults in it no longer having any part of it within the scanout regionof an output.<br/><br/>
            /// Clients should not use the number of outputs the surface is on for framethrottling purposes. The surface might be hidden even if no leave eventhas been sent, and the compositor might expect new surface contentupdates even if no enter event has been sent. The frame event should beused instead.<br/><br/>
            /// </summary>
            void OnLeave(NWayland.Protocols.Wayland.WlSurface eventSender, NWayland.Protocols.Wayland.WlOutput @output);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnEnter(this, WlProxy.FromNative<NWayland.Protocols.Wayland.WlOutput>(arguments[0].IntPtr));
                    break;
                case 1:
                    Events?.OnLeave(this, WlProxy.FromNative<NWayland.Protocols.Wayland.WlOutput>(arguments[0].IntPtr));
                    break;
            }
        }

        /// <summary>
        /// These errors can be emitted in response to wl_surface requests.<br/><br/>
        /// </summary>
        public enum ErrorEnum
        {
            /// <summary>
            /// buffer scale value is invalid<br/><br/>
            /// </summary>
            InvalidScale = 0,
            /// <summary>
            /// buffer transform value is invalid<br/><br/>
            /// </summary>
            InvalidTransform = 1,
            /// <summary>
            /// buffer size is invalid<br/><br/>
            /// </summary>
            InvalidSize = 2,
            /// <summary>
            /// buffer offset is invalid<br/><br/>
            /// </summary>
            InvalidOffset = 3
        }

        private class ProxyFactory : IBindFactory<WlSurface>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface);
            }

            public WlSurface Create(IntPtr handle, int version)
            {
                return new WlSurface(handle, version);
            }
        }

        public static IBindFactory<WlSurface> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "wl_surface";
        public const int InterfaceVersion = 5;

        public WlSurface(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// A seat is a group of keyboards, pointer and touch devices. Thisobject is published as a global during start up, or when such adevice is hot plugged.  A seat typically has a pointer andmaintains a keyboard focus and a pointer focus.<br/><br/>
    /// </summary>
    public sealed unsafe partial class WlSeat : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static WlSeat()
        {
            NWayland.Protocols.Wayland.WlSeat.WlInterface = new WlInterface("wl_seat", 8, new WlMessage[] {
                new WlMessage("get_pointer", "n", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlPointer.WlInterface) }),
                new WlMessage("get_keyboard", "n", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlKeyboard.WlInterface) }),
                new WlMessage("get_touch", "n", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlTouch.WlInterface) }),
                new WlMessage("release", "5", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("capabilities", "u", new WlInterface*[] { null }),
                new WlMessage("name", "2s", new WlInterface*[] { null })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSeat.WlInterface);
        }

        /// <summary>
        /// The ID provided will be initialized to the wl_pointer interfacefor this seat.<br/><br/>
        /// This request only takes effect if the seat has the pointercapability, or has had the pointer capability in the past.It is a protocol violation to issue this request on a seat that hasnever had the pointer capability. The missing_capability error willbe sent in this case.<br/><br/>
        /// </summary>
        public NWayland.Protocols.Wayland.WlPointer GetPointer()
        {
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 0, __args, ref NWayland.Protocols.Wayland.WlPointer.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.Wayland.WlPointer(__ret, Version);
        }

        /// <summary>
        /// The ID provided will be initialized to the wl_keyboard interfacefor this seat.<br/><br/>
        /// This request only takes effect if the seat has the keyboardcapability, or has had the keyboard capability in the past.It is a protocol violation to issue this request on a seat that hasnever had the keyboard capability. The missing_capability error willbe sent in this case.<br/><br/>
        /// </summary>
        public NWayland.Protocols.Wayland.WlKeyboard GetKeyboard()
        {
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 1, __args, ref NWayland.Protocols.Wayland.WlKeyboard.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.Wayland.WlKeyboard(__ret, Version);
        }

        /// <summary>
        /// The ID provided will be initialized to the wl_touch interfacefor this seat.<br/><br/>
        /// This request only takes effect if the seat has the touchcapability, or has had the touch capability in the past.It is a protocol violation to issue this request on a seat that hasnever had the touch capability. The missing_capability error willbe sent in this case.<br/><br/>
        /// </summary>
        public NWayland.Protocols.Wayland.WlTouch GetTouch()
        {
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 2, __args, ref NWayland.Protocols.Wayland.WlTouch.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.Wayland.WlTouch(__ret, Version);
        }

        protected override void Dispose(bool disposing)
        {
            if (Version < 5)
                return;
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 3, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
            /// <summary>
            /// This is emitted whenever a seat gains or loses the pointer,keyboard or touch capabilities.  The argument is a capabilityenum containing the complete set of capabilities this seat has.<br/><br/>
            /// When the pointer capability is added, a client may create awl_pointer object using the wl_seat.get_pointer request. This objectwill receive pointer events until the capability is removed in thefuture.<br/><br/>
            /// When the pointer capability is removed, a client should destroy thewl_pointer objects associated with the seat where the capability wasremoved, using the wl_pointer.release request. No further pointerevents will be received on these objects.<br/><br/>
            /// In some compositors, if a seat regains the pointer capability and aclient has a previously obtained wl_pointer object of version 4 orless, that object may start sending pointer events again. Thisbehavior is considered a misinterpretation of the intended behaviorand must not be relied upon by the client. wl_pointer objects ofversion 5 or later must not send events if created before the mostrecent event notifying the client of an added pointer capability.<br/><br/>
            /// The above behavior also applies to wl_keyboard and wl_touch with thekeyboard and touch capabilities, respectively.<br/><br/>
            /// </summary>
            void OnCapabilities(NWayland.Protocols.Wayland.WlSeat eventSender, CapabilityEnum @capabilities);

            /// <summary>
            /// In a multi-seat configuration the seat name can be used by clients tohelp identify which physical devices the seat represents.<br/><br/>
            /// The seat name is a UTF-8 string with no convention defined for itscontents. Each name is unique among all wl_seat globals. The name isonly guaranteed to be unique for the current compositor instance.<br/><br/>
            /// The same seat names are used for all clients. Thus, the name can beshared across processes to refer to a specific wl_seat global.<br/><br/>
            /// The name event is sent after binding to the seat global. This event isonly sent once per seat object, and the name does not change over thelifetime of the wl_seat global.<br/><br/>
            /// Compositors may re-use the same seat name if the wl_seat global isdestroyed and re-created later.<br/><br/>
            /// </summary>
            void OnName(NWayland.Protocols.Wayland.WlSeat eventSender, string @name);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnCapabilities(this, (CapabilityEnum)arguments[0].UInt32);
                    break;
                case 1:
                    Events?.OnName(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr));
                    break;
            }
        }

        /// <summary>
        /// This is a bitmask of capabilities this seat has; if a member isset, then it is present on the seat.<br/><br/>
        /// </summary>
        [Flags]
        public enum CapabilityEnum
        {
            /// <summary>
            /// the seat has pointer devices<br/><br/>
            /// </summary>
            Pointer = 1,
            /// <summary>
            /// the seat has one or more keyboards<br/><br/>
            /// </summary>
            Keyboard = 2,
            /// <summary>
            /// the seat has touch devices<br/><br/>
            /// </summary>
            Touch = 4
        }

        /// <summary>
        /// These errors can be emitted in response to wl_seat requests.<br/><br/>
        /// </summary>
        public enum ErrorEnum
        {
            /// <summary>
            /// get_pointer, get_keyboard or get_touch called on seat without the matching capability<br/><br/>
            /// </summary>
            MissingCapability = 0
        }

        private class ProxyFactory : IBindFactory<WlSeat>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSeat.WlInterface);
            }

            public WlSeat Create(IntPtr handle, int version)
            {
                return new WlSeat(handle, version);
            }
        }

        public static IBindFactory<WlSeat> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "wl_seat";
        public const int InterfaceVersion = 8;

        public WlSeat(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// The wl_pointer interface represents one or more input devices,such as mice, which control the pointer location and pointer_focusof a seat.<br/><br/>
    /// The wl_pointer interface generates motion, enter and leaveevents for the surfaces that the pointer is located over,and button and axis events for button presses, button releasesand scrolling.<br/><br/>
    /// </summary>
    public sealed unsafe partial class WlPointer : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static WlPointer()
        {
            NWayland.Protocols.Wayland.WlPointer.WlInterface = new WlInterface("wl_pointer", 8, new WlMessage[] {
                new WlMessage("set_cursor", "u?oii", new WlInterface*[] { null, WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface), null, null }),
                new WlMessage("release", "3", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("enter", "uoff", new WlInterface*[] { null, WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface), null, null }),
                new WlMessage("leave", "uo", new WlInterface*[] { null, WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface) }),
                new WlMessage("motion", "uff", new WlInterface*[] { null, null, null }),
                new WlMessage("button", "uuuu", new WlInterface*[] { null, null, null, null }),
                new WlMessage("axis", "uuf", new WlInterface*[] { null, null, null }),
                new WlMessage("frame", "5", new WlInterface*[] { }),
                new WlMessage("axis_source", "5u", new WlInterface*[] { null }),
                new WlMessage("axis_stop", "5uu", new WlInterface*[] { null, null }),
                new WlMessage("axis_discrete", "5ui", new WlInterface*[] { null, null }),
                new WlMessage("axis_value120", "8ui", new WlInterface*[] { null, null })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlPointer.WlInterface);
        }

        /// <summary>
        /// Set the pointer surface, i.e., the surface that contains thepointer image (cursor). This request gives the surface the roleof a cursor. If the surface already has another role, it raisesa protocol error.<br/><br/>
        /// The cursor actually changes only if the pointerfocus for this device is one of the requesting client's surfacesor the surface parameter is the current pointer surface. Ifthere was a previous surface set with this request it isreplaced. If surface is NULL, the pointer image is hidden.<br/><br/>
        /// The parameters hotspot_x and hotspot_y define the position ofthe pointer surface relative to the pointer location. Itstop-left corner is always at (x, y) - (hotspot_x, hotspot_y),where (x, y) are the coordinates of the pointer location, insurface-local coordinates.<br/><br/>
        /// On surface.attach requests to the pointer surface, hotspot_xand hotspot_y are decremented by the x and y parameterspassed to the request. Attach must be confirmed bywl_surface.commit as usual.<br/><br/>
        /// The hotspot can also be updated by passing the currently setpointer surface to this request with new values for hotspot_xand hotspot_y.<br/><br/>
        /// The current and pending input regions of the wl_surface arecleared, and wl_surface.set_input_region is ignored until thewl_surface is no longer used as the cursor. When the use as acursor ends, the current and pending input regions becomeundefined, and the wl_surface is unmapped.<br/><br/>
        /// The serial parameter must match the latest wl_pointer.enterserial number sent to the client. Otherwise the request will beignored.<br/><br/>
        /// </summary>
        public void SetCursor(uint @serial, NWayland.Protocols.Wayland.WlSurface? @surface, int @hotspotX, int @hotspotY)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                @serial,
                @surface,
                @hotspotX,
                @hotspotY
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
        }

        protected override void Dispose(bool disposing)
        {
            if (Version < 3)
                return;
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
            /// <summary>
            /// Notification that this seat's pointer is focused on a certainsurface.<br/><br/>
            /// When a seat's focus enters a surface, the pointer imageis undefined and a client should respond to this event by settingan appropriate pointer image with the set_cursor request.<br/><br/>
            /// </summary>
            void OnEnter(NWayland.Protocols.Wayland.WlPointer eventSender, uint @serial, NWayland.Protocols.Wayland.WlSurface @surface, WlFixed @surfaceX, WlFixed @surfaceY);

            /// <summary>
            /// Notification that this seat's pointer is no longer focused ona certain surface.<br/><br/>
            /// The leave notification is sent before the enter notificationfor the new focus.<br/><br/>
            /// </summary>
            void OnLeave(NWayland.Protocols.Wayland.WlPointer eventSender, uint @serial, NWayland.Protocols.Wayland.WlSurface @surface);

            /// <summary>
            /// Notification of pointer location change. The argumentssurface_x and surface_y are the location relative to thefocused surface.<br/><br/>
            /// </summary>
            void OnMotion(NWayland.Protocols.Wayland.WlPointer eventSender, uint @time, WlFixed @surfaceX, WlFixed @surfaceY);

            /// <summary>
            /// Mouse button click and release notifications.<br/><br/>
            /// The location of the click is given by the last motion orenter event.The time argument is a timestamp with millisecondgranularity, with an undefined base.<br/><br/>
            /// The button is a button code as defined in the Linux kernel'slinux/input-event-codes.h header file, e.g. BTN_LEFT.<br/><br/>
            /// Any 16-bit button code value is reserved for future additions to thekernel's event code list. All other button codes above 0xFFFF arecurrently undefined but may be used in future versions of thisprotocol.<br/><br/>
            /// </summary>
            void OnButton(NWayland.Protocols.Wayland.WlPointer eventSender, uint @serial, uint @time, uint @button, ButtonStateEnum @state);

            /// <summary>
            /// Scroll and other axis notifications.<br/><br/>
            /// For scroll events (vertical and horizontal scroll axes), thevalue parameter is the length of a vector along the specifiedaxis in a coordinate space identical to those of motion events,representing a relative movement along the specified axis.<br/><br/>
            /// For devices that support movements non-parallel to axes multipleaxis events will be emitted.<br/><br/>
            /// When applicable, for example for touch pads, the server canchoose to emit scroll events where the motion vector isequivalent to a motion event vector.<br/><br/>
            /// When applicable, a client can transform its content relative to thescroll distance.<br/><br/>
            /// </summary>
            void OnAxis(NWayland.Protocols.Wayland.WlPointer eventSender, uint @time, AxisEnum @axis, WlFixed @value);

            /// <summary>
            /// Indicates the end of a set of events that logically belong together.A client is expected to accumulate the data in all events within theframe before proceeding.<br/><br/>
            /// All wl_pointer events before a wl_pointer.frame event belonglogically together. For example, in a diagonal scroll motion thecompositor will send an optional wl_pointer.axis_source event, twowl_pointer.axis events (horizontal and vertical) and finally awl_pointer.frame event. The client may use this information tocalculate a diagonal vector for scrolling.<br/><br/>
            /// When multiple wl_pointer.axis events occur within the same frame,the motion vector is the combined motion of all events.When a wl_pointer.axis and a wl_pointer.axis_stop event occur withinthe same frame, this indicates that axis movement in one axis hasstopped but continues in the other axis.When multiple wl_pointer.axis_stop events occur within the sameframe, this indicates that these axes stopped in the same instance.<br/><br/>
            /// A wl_pointer.frame event is sent for every logical event group,even if the group only contains a single wl_pointer event.Specifically, a client may get a sequence: motion, frame, button,frame, axis, frame, axis_stop, frame.<br/><br/>
            /// The wl_pointer.enter and wl_pointer.leave events are logical eventsgenerated by the compositor and not the hardware. These events arealso grouped by a wl_pointer.frame. When a pointer moves from onesurface to another, a compositor should group thewl_pointer.leave event within the same wl_pointer.frame.However, a client must not rely on wl_pointer.leave andwl_pointer.enter being in the same wl_pointer.frame.Compositor-specific policies may require the wl_pointer.leave andwl_pointer.enter event being split across multiple wl_pointer.framegroups.<br/><br/>
            /// </summary>
            void OnFrame(NWayland.Protocols.Wayland.WlPointer eventSender);

            /// <summary>
            /// Source information for scroll and other axes.<br/><br/>
            /// This event does not occur on its own. It is sent before awl_pointer.frame event and carries the source information forall events within that frame.<br/><br/>
            /// The source specifies how this event was generated. If the source iswl_pointer.axis_source.finger, a wl_pointer.axis_stop event will besent when the user lifts the finger off the device.<br/><br/>
            /// If the source is wl_pointer.axis_source.wheel,wl_pointer.axis_source.wheel_tilt orwl_pointer.axis_source.continuous, a wl_pointer.axis_stop event mayor may not be sent. Whether a compositor sends an axis_stop eventfor these sources is hardware-specific and implementation-dependent;clients must not rely on receiving an axis_stop event for thesescroll sources and should treat scroll sequences from these scrollsources as unterminated by default.<br/><br/>
            /// This event is optional. If the source is unknown for a particularaxis event sequence, no event is sent.Only one wl_pointer.axis_source event is permitted per frame.<br/><br/>
            /// The order of wl_pointer.axis_discrete and wl_pointer.axis_source isnot guaranteed.<br/><br/>
            /// </summary>
            void OnAxisSource(NWayland.Protocols.Wayland.WlPointer eventSender, AxisSourceEnum @axisSource);

            /// <summary>
            /// Stop notification for scroll and other axes.<br/><br/>
            /// For some wl_pointer.axis_source types, a wl_pointer.axis_stop eventis sent to notify a client that the axis sequence has terminated.This enables the client to implement kinetic scrolling.See the wl_pointer.axis_source documentation for information on whenthis event may be generated.<br/><br/>
            /// Any wl_pointer.axis events with the same axis_source after thisevent should be considered as the start of a new axis motion.<br/><br/>
            /// The timestamp is to be interpreted identical to the timestamp in thewl_pointer.axis event. The timestamp value may be the same as apreceding wl_pointer.axis event.<br/><br/>
            /// </summary>
            void OnAxisStop(NWayland.Protocols.Wayland.WlPointer eventSender, uint @time, AxisEnum @axis);

            /// <summary>
            /// Discrete step information for scroll and other axes.<br/><br/>
            /// This event carries the axis value of the wl_pointer.axis event indiscrete steps (e.g. mouse wheel clicks).<br/><br/>
            /// This event is deprecated with wl_pointer version 8 - this event is notsent to clients supporting version 8 or later.<br/><br/>
            /// This event does not occur on its own, it is coupled with awl_pointer.axis event that represents this axis value on acontinuous scale. The protocol guarantees that each axis_discreteevent is always followed by exactly one axis event with the sameaxis number within the same wl_pointer.frame. Note that the protocolallows for other events to occur between the axis_discrete andits coupled axis event, including other axis_discrete or axisevents. A wl_pointer.frame must not contain more than one axis_discreteevent per axis type.<br/><br/>
            /// This event is optional; continuous scrolling deviceslike two-finger scrolling on touchpads do not have discretesteps and do not generate this event.<br/><br/>
            /// The discrete value carries the directional information. e.g. a valueof -2 is two steps towards the negative direction of this axis.<br/><br/>
            /// The axis number is identical to the axis number in the associatedaxis event.<br/><br/>
            /// The order of wl_pointer.axis_discrete and wl_pointer.axis_source isnot guaranteed.<br/><br/>
            /// </summary>
            void OnAxisDiscrete(NWayland.Protocols.Wayland.WlPointer eventSender, AxisEnum @axis, int @discrete);

            /// <summary>
            /// Discrete high-resolution scroll information.<br/><br/>
            /// This event carries high-resolution wheel scroll information,with each multiple of 120 representing one logical scroll step(a wheel detent). For example, an axis_value120 of 30 is one quarter ofa logical scroll step in the positive direction, a value120 of-240 are two logical scroll steps in the negative direction within thesame hardware event.Clients that rely on discrete scrolling should accumulate thevalue120 to multiples of 120 before processing the event.<br/><br/>
            /// The value120 must not be zero.<br/><br/>
            /// This event replaces the wl_pointer.axis_discrete event in clientssupporting wl_pointer version 8 or later.<br/><br/>
            /// Where a wl_pointer.axis_source event occurs in the samewl_pointer.frame, the axis source applies to this event.<br/><br/>
            /// The order of wl_pointer.axis_value120 and wl_pointer.axis_source isnot guaranteed.<br/><br/>
            /// </summary>
            void OnAxisValue120(NWayland.Protocols.Wayland.WlPointer eventSender, AxisEnum @axis, int @value120);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnEnter(this, arguments[0].UInt32, WlProxy.FromNative<NWayland.Protocols.Wayland.WlSurface>(arguments[1].IntPtr), arguments[2].WlFixed, arguments[3].WlFixed);
                    break;
                case 1:
                    Events?.OnLeave(this, arguments[0].UInt32, WlProxy.FromNative<NWayland.Protocols.Wayland.WlSurface>(arguments[1].IntPtr));
                    break;
                case 2:
                    Events?.OnMotion(this, arguments[0].UInt32, arguments[1].WlFixed, arguments[2].WlFixed);
                    break;
                case 3:
                    Events?.OnButton(this, arguments[0].UInt32, arguments[1].UInt32, arguments[2].UInt32, (ButtonStateEnum)arguments[3].UInt32);
                    break;
                case 4:
                    Events?.OnAxis(this, arguments[0].UInt32, (AxisEnum)arguments[1].UInt32, arguments[2].WlFixed);
                    break;
                case 5:
                    Events?.OnFrame(this);
                    break;
                case 6:
                    Events?.OnAxisSource(this, (AxisSourceEnum)arguments[0].UInt32);
                    break;
                case 7:
                    Events?.OnAxisStop(this, arguments[0].UInt32, (AxisEnum)arguments[1].UInt32);
                    break;
                case 8:
                    Events?.OnAxisDiscrete(this, (AxisEnum)arguments[0].UInt32, arguments[1].Int32);
                    break;
                case 9:
                    Events?.OnAxisValue120(this, (AxisEnum)arguments[0].UInt32, arguments[1].Int32);
                    break;
            }
        }

        public enum ErrorEnum
        {
            /// <summary>
            /// given wl_surface has another role<br/><br/>
            /// </summary>
            Role = 0
        }

        /// <summary>
        /// Describes the physical state of a button that produced the buttonevent.<br/><br/>
        /// </summary>
        public enum ButtonStateEnum
        {
            /// <summary>
            /// the button is not pressed<br/><br/>
            /// </summary>
            Released = 0,
            /// <summary>
            /// the button is pressed<br/><br/>
            /// </summary>
            Pressed = 1
        }

        /// <summary>
        /// Describes the axis types of scroll events.<br/><br/>
        /// </summary>
        public enum AxisEnum
        {
            /// <summary>
            /// vertical axis<br/><br/>
            /// </summary>
            VerticalScroll = 0,
            /// <summary>
            /// horizontal axis<br/><br/>
            /// </summary>
            HorizontalScroll = 1
        }

        /// <summary>
        /// Describes the source types for axis events. This indicates to theclient how an axis event was physically generated; a client mayadjust the user interface accordingly. For example, scroll eventsfrom a "finger" source may be in a smooth coordinate space withkinetic scrolling whereas a "wheel" source may be in discrete stepsof a number of lines.<br/><br/>
        /// The "continuous" axis source is a device generating events in acontinuous coordinate space, but using something other than afinger. One example for this source is button-based scrolling wherethe vertical motion of a device is converted to scroll events whilea button is held down.<br/><br/>
        /// The "wheel tilt" axis source indicates that the actual device is awheel but the scroll event is not caused by a rotation but a(usually sideways) tilt of the wheel.<br/><br/>
        /// </summary>
        public enum AxisSourceEnum
        {
            /// <summary>
            /// a physical wheel rotation<br/><br/>
            /// </summary>
            Wheel = 0,
            /// <summary>
            /// finger on a touch surface<br/><br/>
            /// </summary>
            Finger = 1,
            /// <summary>
            /// continuous coordinate space<br/><br/>
            /// </summary>
            Continuous = 2,
            /// <summary>
            /// a physical wheel tilt<br/><br/>
            /// </summary>
            WheelTilt = 3
        }

        private class ProxyFactory : IBindFactory<WlPointer>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlPointer.WlInterface);
            }

            public WlPointer Create(IntPtr handle, int version)
            {
                return new WlPointer(handle, version);
            }
        }

        public static IBindFactory<WlPointer> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "wl_pointer";
        public const int InterfaceVersion = 8;

        public WlPointer(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// The wl_keyboard interface represents one or more keyboardsassociated with a seat.<br/><br/>
    /// </summary>
    public sealed unsafe partial class WlKeyboard : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static WlKeyboard()
        {
            NWayland.Protocols.Wayland.WlKeyboard.WlInterface = new WlInterface("wl_keyboard", 8, new WlMessage[] {
                new WlMessage("release", "3", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("keymap", "uhu", new WlInterface*[] { null, null, null }),
                new WlMessage("enter", "uoa", new WlInterface*[] { null, WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface), null }),
                new WlMessage("leave", "uo", new WlInterface*[] { null, WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface) }),
                new WlMessage("key", "uuuu", new WlInterface*[] { null, null, null, null }),
                new WlMessage("modifiers", "uuuuu", new WlInterface*[] { null, null, null, null, null }),
                new WlMessage("repeat_info", "4ii", new WlInterface*[] { null, null })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlKeyboard.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            if (Version < 3)
                return;
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
            /// <summary>
            /// This event provides a file descriptor to the client which can bememory-mapped in read-only mode to provide a keyboard mappingdescription.<br/><br/>
            /// From version 7 onwards, the fd must be mapped with MAP_PRIVATE bythe recipient, as MAP_SHARED may fail.<br/><br/>
            /// </summary>
            void OnKeymap(NWayland.Protocols.Wayland.WlKeyboard eventSender, KeymapFormatEnum @format, int @fd, uint @size);

            /// <summary>
            /// Notification that this seat's keyboard focus is on a certainsurface.<br/><br/>
            /// The compositor must send the wl_keyboard.modifiers event after thisevent.<br/><br/>
            /// </summary>
            void OnEnter(NWayland.Protocols.Wayland.WlKeyboard eventSender, uint @serial, NWayland.Protocols.Wayland.WlSurface @surface, ReadOnlySpan<int> @keys);

            /// <summary>
            /// Notification that this seat's keyboard focus is no longer ona certain surface.<br/><br/>
            /// The leave notification is sent before the enter notificationfor the new focus.<br/><br/>
            /// After this event client must assume that all keys, including modifiers,are lifted and also it must stop key repeating if there's some going on.<br/><br/>
            /// </summary>
            void OnLeave(NWayland.Protocols.Wayland.WlKeyboard eventSender, uint @serial, NWayland.Protocols.Wayland.WlSurface @surface);

            /// <summary>
            /// A key was pressed or released.The time argument is a timestamp with millisecondgranularity, with an undefined base.<br/><br/>
            /// The key is a platform-specific key code that can be interpretedby feeding it to the keyboard mapping (see the keymap event).<br/><br/>
            /// If this event produces a change in modifiers, then the resultingwl_keyboard.modifiers event must be sent after this event.<br/><br/>
            /// </summary>
            void OnKey(NWayland.Protocols.Wayland.WlKeyboard eventSender, uint @serial, uint @time, uint @key, KeyStateEnum @state);

            /// <summary>
            /// Notifies clients that the modifier and/or group state haschanged, and it should update its local state.<br/><br/>
            /// </summary>
            void OnModifiers(NWayland.Protocols.Wayland.WlKeyboard eventSender, uint @serial, uint @modsDepressed, uint @modsLatched, uint @modsLocked, uint @group);

            /// <summary>
            /// Informs the client about the keyboard's repeat rate and delay.<br/><br/>
            /// This event is sent as soon as the wl_keyboard object has been created,and is guaranteed to be received by the client before any key pressevent.<br/><br/>
            /// Negative values for either rate or delay are illegal. A rate of zerowill disable any repeating (regardless of the value of delay).<br/><br/>
            /// This event can be sent later on as well with a new value if necessary,so clients should continue listening for the event past the creationof wl_keyboard.<br/><br/>
            /// </summary>
            void OnRepeatInfo(NWayland.Protocols.Wayland.WlKeyboard eventSender, int @rate, int @delay);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnKeymap(this, (KeymapFormatEnum)arguments[0].UInt32, arguments[1].Int32, arguments[2].UInt32);
                    break;
                case 1:
                    Events?.OnEnter(this, arguments[0].UInt32, WlProxy.FromNative<NWayland.Protocols.Wayland.WlSurface>(arguments[1].IntPtr), WlArray.SpanFromWlArrayPtr<int>(arguments[2].IntPtr));
                    break;
                case 2:
                    Events?.OnLeave(this, arguments[0].UInt32, WlProxy.FromNative<NWayland.Protocols.Wayland.WlSurface>(arguments[1].IntPtr));
                    break;
                case 3:
                    Events?.OnKey(this, arguments[0].UInt32, arguments[1].UInt32, arguments[2].UInt32, (KeyStateEnum)arguments[3].UInt32);
                    break;
                case 4:
                    Events?.OnModifiers(this, arguments[0].UInt32, arguments[1].UInt32, arguments[2].UInt32, arguments[3].UInt32, arguments[4].UInt32);
                    break;
                case 5:
                    Events?.OnRepeatInfo(this, arguments[0].Int32, arguments[1].Int32);
                    break;
            }
        }

        /// <summary>
        /// This specifies the format of the keymap provided to theclient with the wl_keyboard.keymap event.<br/><br/>
        /// </summary>
        public enum KeymapFormatEnum
        {
            /// <summary>
            /// no keymap; client must understand how to interpret the raw keycode<br/><br/>
            /// </summary>
            NoKeymap = 0,
            /// <summary>
            /// libxkbcommon compatible, null-terminated string; to determine the xkb keycode, clients must add 8 to the key event keycode<br/><br/>
            /// </summary>
            XkbV1 = 1
        }

        /// <summary>
        /// Describes the physical state of a key that produced the key event.<br/><br/>
        /// </summary>
        public enum KeyStateEnum
        {
            /// <summary>
            /// key is not pressed<br/><br/>
            /// </summary>
            Released = 0,
            /// <summary>
            /// key is pressed<br/><br/>
            /// </summary>
            Pressed = 1
        }

        private class ProxyFactory : IBindFactory<WlKeyboard>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlKeyboard.WlInterface);
            }

            public WlKeyboard Create(IntPtr handle, int version)
            {
                return new WlKeyboard(handle, version);
            }
        }

        public static IBindFactory<WlKeyboard> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "wl_keyboard";
        public const int InterfaceVersion = 8;

        public WlKeyboard(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// The wl_touch interface represents a touchscreenassociated with a seat.<br/><br/>
    /// Touch interactions can consist of one or more contacts.For each contact, a series of events is generated, startingwith a down event, followed by zero or more motion events,and ending with an up event. Events relating to the samecontact point can be identified by the ID of the sequence.<br/><br/>
    /// </summary>
    public sealed unsafe partial class WlTouch : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static WlTouch()
        {
            NWayland.Protocols.Wayland.WlTouch.WlInterface = new WlInterface("wl_touch", 8, new WlMessage[] {
                new WlMessage("release", "3", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("down", "uuoiff", new WlInterface*[] { null, null, WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface), null, null, null }),
                new WlMessage("up", "uui", new WlInterface*[] { null, null, null }),
                new WlMessage("motion", "uiff", new WlInterface*[] { null, null, null, null }),
                new WlMessage("frame", "", new WlInterface*[] { }),
                new WlMessage("cancel", "", new WlInterface*[] { }),
                new WlMessage("shape", "6iff", new WlInterface*[] { null, null, null }),
                new WlMessage("orientation", "6if", new WlInterface*[] { null, null })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlTouch.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            if (Version < 3)
                return;
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
            /// <summary>
            /// A new touch point has appeared on the surface. This touch point isassigned a unique ID. Future events from this touch point referencethis ID. The ID ceases to be valid after a touch up event and may bereused in the future.<br/><br/>
            /// </summary>
            void OnDown(NWayland.Protocols.Wayland.WlTouch eventSender, uint @serial, uint @time, NWayland.Protocols.Wayland.WlSurface @surface, int @id, WlFixed @x, WlFixed @y);

            /// <summary>
            /// The touch point has disappeared. No further events will be sent forthis touch point and the touch point's ID is released and may bereused in a future touch down event.<br/><br/>
            /// </summary>
            void OnUp(NWayland.Protocols.Wayland.WlTouch eventSender, uint @serial, uint @time, int @id);

            /// <summary>
            /// A touch point has changed coordinates.<br/><br/>
            /// </summary>
            void OnMotion(NWayland.Protocols.Wayland.WlTouch eventSender, uint @time, int @id, WlFixed @x, WlFixed @y);

            /// <summary>
            /// Indicates the end of a set of events that logically belong together.A client is expected to accumulate the data in all events within theframe before proceeding.<br/><br/>
            /// A wl_touch.frame terminates at least one event but otherwise noguarantee is provided about the set of events within a frame. A clientmust assume that any state not updated in a frame is unchanged from thepreviously known state.<br/><br/>
            /// </summary>
            void OnFrame(NWayland.Protocols.Wayland.WlTouch eventSender);

            /// <summary>
            /// Sent if the compositor decides the touch stream is a globalgesture. No further events are sent to the clients from thatparticular gesture. Touch cancellation applies to all touch pointscurrently active on this client's surface. The client isresponsible for finalizing the touch points, future touch points onthis surface may reuse the touch point ID.<br/><br/>
            /// </summary>
            void OnCancel(NWayland.Protocols.Wayland.WlTouch eventSender);

            /// <summary>
            /// Sent when a touchpoint has changed its shape.<br/><br/>
            /// This event does not occur on its own. It is sent before awl_touch.frame event and carries the new shape information forany previously reported, or new touch points of that frame.<br/><br/>
            /// Other events describing the touch point such as wl_touch.down,wl_touch.motion or wl_touch.orientation may be sent within thesame wl_touch.frame. A client should treat these events as a singlelogical touch point update. The order of wl_touch.shape,wl_touch.orientation and wl_touch.motion is not guaranteed.A wl_touch.down event is guaranteed to occur before the firstwl_touch.shape event for this touch ID but both events may occur withinthe same wl_touch.frame.<br/><br/>
            /// A touchpoint shape is approximated by an ellipse through the major andminor axis length. The major axis length describes the longer diameterof the ellipse, while the minor axis length describes the shorterdiameter. Major and minor are orthogonal and both are specified insurface-local coordinates. The center of the ellipse is always at thetouchpoint location as reported by wl_touch.down or wl_touch.move.<br/><br/>
            /// This event is only sent by the compositor if the touch device supportsshape reports. The client has to make reasonable assumptions about theshape if it did not receive this event.<br/><br/>
            /// </summary>
            void OnShape(NWayland.Protocols.Wayland.WlTouch eventSender, int @id, WlFixed @major, WlFixed @minor);

            /// <summary>
            /// Sent when a touchpoint has changed its orientation.<br/><br/>
            /// This event does not occur on its own. It is sent before awl_touch.frame event and carries the new shape information forany previously reported, or new touch points of that frame.<br/><br/>
            /// Other events describing the touch point such as wl_touch.down,wl_touch.motion or wl_touch.shape may be sent within thesame wl_touch.frame. A client should treat these events as a singlelogical touch point update. The order of wl_touch.shape,wl_touch.orientation and wl_touch.motion is not guaranteed.A wl_touch.down event is guaranteed to occur before the firstwl_touch.orientation event for this touch ID but both events may occurwithin the same wl_touch.frame.<br/><br/>
            /// The orientation describes the clockwise angle of a touchpoint's majoraxis to the positive surface y-axis and is normalized to the -180 to+180 degree range. The granularity of orientation depends on the touchdevice, some devices only support binary rotation values between 0 and90 degrees.<br/><br/>
            /// This event is only sent by the compositor if the touch device supportsorientation reports.<br/><br/>
            /// </summary>
            void OnOrientation(NWayland.Protocols.Wayland.WlTouch eventSender, int @id, WlFixed @orientation);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnDown(this, arguments[0].UInt32, arguments[1].UInt32, WlProxy.FromNative<NWayland.Protocols.Wayland.WlSurface>(arguments[2].IntPtr), arguments[3].Int32, arguments[4].WlFixed, arguments[5].WlFixed);
                    break;
                case 1:
                    Events?.OnUp(this, arguments[0].UInt32, arguments[1].UInt32, arguments[2].Int32);
                    break;
                case 2:
                    Events?.OnMotion(this, arguments[0].UInt32, arguments[1].Int32, arguments[2].WlFixed, arguments[3].WlFixed);
                    break;
                case 3:
                    Events?.OnFrame(this);
                    break;
                case 4:
                    Events?.OnCancel(this);
                    break;
                case 5:
                    Events?.OnShape(this, arguments[0].Int32, arguments[1].WlFixed, arguments[2].WlFixed);
                    break;
                case 6:
                    Events?.OnOrientation(this, arguments[0].Int32, arguments[1].WlFixed);
                    break;
            }
        }

        private class ProxyFactory : IBindFactory<WlTouch>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlTouch.WlInterface);
            }

            public WlTouch Create(IntPtr handle, int version)
            {
                return new WlTouch(handle, version);
            }
        }

        public static IBindFactory<WlTouch> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "wl_touch";
        public const int InterfaceVersion = 8;

        public WlTouch(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// An output describes part of the compositor geometry.  Thecompositor works in the 'compositor coordinate system' and anoutput corresponds to a rectangular area in that space that isactually visible.  This typically corresponds to a monitor thatdisplays part of the compositor space.  This object is publishedas global during start up, or when a monitor is hotplugged.<br/><br/>
    /// </summary>
    public sealed unsafe partial class WlOutput : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static WlOutput()
        {
            NWayland.Protocols.Wayland.WlOutput.WlInterface = new WlInterface("wl_output", 4, new WlMessage[] {
                new WlMessage("release", "3", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("geometry", "iiiiissi", new WlInterface*[] { null, null, null, null, null, null, null, null }),
                new WlMessage("mode", "uiii", new WlInterface*[] { null, null, null, null }),
                new WlMessage("done", "2", new WlInterface*[] { }),
                new WlMessage("scale", "2i", new WlInterface*[] { null }),
                new WlMessage("name", "4s", new WlInterface*[] { null }),
                new WlMessage("description", "4s", new WlInterface*[] { null })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlOutput.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            if (Version < 3)
                return;
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
            /// <summary>
            /// The geometry event describes geometric properties of the output.The event is sent when binding to the output object and wheneverany of the properties change.<br/><br/>
            /// The physical size can be set to zero if it doesn't make sense for thisoutput (e.g. for projectors or virtual outputs).<br/><br/>
            /// The geometry event will be followed by a done event (starting fromversion 2).<br/><br/>
            /// Note: wl_output only advertises partial information about the outputposition and identification. Some compositors, for instance those notimplementing a desktop-style output layout or those exposing virtualoutputs, might fake this information. Instead of using x and y, clientsshould use xdg_output.logical_position. Instead of using make and model,clients should use name and description.<br/><br/>
            /// </summary>
            void OnGeometry(NWayland.Protocols.Wayland.WlOutput eventSender, int @x, int @y, int @physicalWidth, int @physicalHeight, SubpixelEnum @subpixel, string @make, string @model, TransformEnum @transform);

            /// <summary>
            /// The mode event describes an available mode for the output.<br/><br/>
            /// The event is sent when binding to the output object and therewill always be one mode, the current mode.  The event is sentagain if an output changes mode, for the mode that is nowcurrent.  In other words, the current mode is always the lastmode that was received with the current flag set.<br/><br/>
            /// Non-current modes are deprecated. A compositor can decide to onlyadvertise the current mode and never send other modes. Clientsshould not rely on non-current modes.<br/><br/>
            /// The size of a mode is given in physical hardware units ofthe output device. This is not necessarily the same asthe output size in the global compositor space. For instance,the output may be scaled, as described in wl_output.scale,or transformed, as described in wl_output.transform. Clientswilling to retrieve the output size in the global compositorspace should use xdg_output.logical_size instead.<br/><br/>
            /// The vertical refresh rate can be set to zero if it doesn't makesense for this output (e.g. for virtual outputs).<br/><br/>
            /// The mode event will be followed by a done event (starting fromversion 2).<br/><br/>
            /// Clients should not use the refresh rate to schedule frames. Instead,they should use the wl_surface.frame event or the presentation-timeprotocol.<br/><br/>
            /// Note: this information is not always meaningful for all outputs. Somecompositors, such as those exposing virtual outputs, might fake therefresh rate or the size.<br/><br/>
            /// </summary>
            void OnMode(NWayland.Protocols.Wayland.WlOutput eventSender, ModeEnum @flags, int @width, int @height, int @refresh);

            /// <summary>
            /// This event is sent after all other properties have beensent after binding to the output object and after anyother property changes done after that. This allowschanges to the output properties to be seen asatomic, even if they happen via multiple events.<br/><br/>
            /// </summary>
            void OnDone(NWayland.Protocols.Wayland.WlOutput eventSender);

            /// <summary>
            /// This event contains scaling geometry informationthat is not in the geometry event. It may be sent afterbinding the output object or if the output scale changeslater. If it is not sent, the client should assume ascale of 1.<br/><br/>
            /// A scale larger than 1 means that the compositor willautomatically scale surface buffers by this amountwhen rendering. This is used for very high resolutiondisplays where applications rendering at the nativeresolution would be too small to be legible.<br/><br/>
            /// It is intended that scaling aware clients track thecurrent output of a surface, and if it is on a scaledoutput it should use wl_surface.set_buffer_scale withthe scale of the output. That way the compositor canavoid scaling the surface, and the client can supplya higher detail image.<br/><br/>
            /// The scale event will be followed by a done event.<br/><br/>
            /// </summary>
            void OnScale(NWayland.Protocols.Wayland.WlOutput eventSender, int @factor);

            /// <summary>
            /// Many compositors will assign user-friendly names to their outputs, showthem to the user, allow the user to refer to an output, etc. The clientmay wish to know this name as well to offer the user similar behaviors.<br/><br/>
            /// The name is a UTF-8 string with no convention defined for its contents.Each name is unique among all wl_output globals. The name is onlyguaranteed to be unique for the compositor instance.<br/><br/>
            /// The same output name is used for all clients for a given wl_outputglobal. Thus, the name can be shared across processes to refer to aspecific wl_output global.<br/><br/>
            /// The name is not guaranteed to be persistent across sessions, thus cannotbe used to reliably identify an output in e.g. configuration files.<br/><br/>
            /// Examples of names include 'HDMI-A-1', 'WL-1', 'X11-1', etc. However, donot assume that the name is a reflection of an underlying DRM connector,X11 connection, etc.<br/><br/>
            /// The name event is sent after binding the output object. This event isonly sent once per output object, and the name does not change over thelifetime of the wl_output global.<br/><br/>
            /// Compositors may re-use the same output name if the wl_output global isdestroyed and re-created later. Compositors should avoid re-using thesame name if possible.<br/><br/>
            /// The name event will be followed by a done event.<br/><br/>
            /// </summary>
            void OnName(NWayland.Protocols.Wayland.WlOutput eventSender, string @name);

            /// <summary>
            /// Many compositors can produce human-readable descriptions of theiroutputs. The client may wish to know this description as well, e.g. foroutput selection purposes.<br/><br/>
            /// The description is a UTF-8 string with no convention defined for itscontents. The description is not guaranteed to be unique among allwl_output globals. Examples might include 'Foocorp 11" Display' or'Virtual X11 output via :1'.<br/><br/>
            /// The description event is sent after binding the output object andwhenever the description changes. The description is optional, and maynot be sent at all.<br/><br/>
            /// The description event will be followed by a done event.<br/><br/>
            /// </summary>
            void OnDescription(NWayland.Protocols.Wayland.WlOutput eventSender, string @description);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnGeometry(this, arguments[0].Int32, arguments[1].Int32, arguments[2].Int32, arguments[3].Int32, (SubpixelEnum)arguments[4].Int32, Marshal.PtrToStringAnsi(arguments[5].IntPtr), Marshal.PtrToStringAnsi(arguments[6].IntPtr), (TransformEnum)arguments[7].Int32);
                    break;
                case 1:
                    Events?.OnMode(this, (ModeEnum)arguments[0].UInt32, arguments[1].Int32, arguments[2].Int32, arguments[3].Int32);
                    break;
                case 2:
                    Events?.OnDone(this);
                    break;
                case 3:
                    Events?.OnScale(this, arguments[0].Int32);
                    break;
                case 4:
                    Events?.OnName(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr));
                    break;
                case 5:
                    Events?.OnDescription(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr));
                    break;
            }
        }

        /// <summary>
        /// This enumeration describes how the physicalpixels on an output are laid out.<br/><br/>
        /// </summary>
        public enum SubpixelEnum
        {
            /// <summary>
            /// unknown geometry<br/><br/>
            /// </summary>
            Unknown = 0,
            /// <summary>
            /// no geometry<br/><br/>
            /// </summary>
            None = 1,
            /// <summary>
            /// horizontal RGB<br/><br/>
            /// </summary>
            HorizontalRgb = 2,
            /// <summary>
            /// horizontal BGR<br/><br/>
            /// </summary>
            HorizontalBgr = 3,
            /// <summary>
            /// vertical RGB<br/><br/>
            /// </summary>
            VerticalRgb = 4,
            /// <summary>
            /// vertical BGR<br/><br/>
            /// </summary>
            VerticalBgr = 5
        }

        /// <summary>
        /// This describes the transform that a compositor will apply to asurface to compensate for the rotation or mirroring of anoutput device.<br/><br/>
        /// The flipped values correspond to an initial flip around avertical axis followed by rotation.<br/><br/>
        /// The purpose is mainly to allow clients to render accordingly andtell the compositor, so that for fullscreen surfaces, thecompositor will still be able to scan out directly from clientsurfaces.<br/><br/>
        /// </summary>
        public enum TransformEnum
        {
            /// <summary>
            /// no transform<br/><br/>
            /// </summary>
            Normal = 0,
            /// <summary>
            /// 90 degrees counter-clockwise<br/><br/>
            /// </summary>
            k_90 = 1,
            /// <summary>
            /// 180 degrees counter-clockwise<br/><br/>
            /// </summary>
            k_180 = 2,
            /// <summary>
            /// 270 degrees counter-clockwise<br/><br/>
            /// </summary>
            k_270 = 3,
            /// <summary>
            /// 180 degree flip around a vertical axis<br/><br/>
            /// </summary>
            Flipped = 4,
            /// <summary>
            /// flip and rotate 90 degrees counter-clockwise<br/><br/>
            /// </summary>
            Flipped90 = 5,
            /// <summary>
            /// flip and rotate 180 degrees counter-clockwise<br/><br/>
            /// </summary>
            Flipped180 = 6,
            /// <summary>
            /// flip and rotate 270 degrees counter-clockwise<br/><br/>
            /// </summary>
            Flipped270 = 7
        }

        /// <summary>
        /// These flags describe properties of an output mode.They are used in the flags bitfield of the mode event.<br/><br/>
        /// </summary>
        [Flags]
        public enum ModeEnum
        {
            /// <summary>
            /// indicates this is the current mode<br/><br/>
            /// </summary>
            Current = 0x1,
            /// <summary>
            /// indicates this is the preferred mode<br/><br/>
            /// </summary>
            Preferred = 0x2
        }

        private class ProxyFactory : IBindFactory<WlOutput>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlOutput.WlInterface);
            }

            public WlOutput Create(IntPtr handle, int version)
            {
                return new WlOutput(handle, version);
            }
        }

        public static IBindFactory<WlOutput> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "wl_output";
        public const int InterfaceVersion = 4;

        public WlOutput(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// A region object describes an area.<br/><br/>
    /// Region objects are used to describe the opaque and inputregions of a surface.<br/><br/>
    /// </summary>
    public sealed unsafe partial class WlRegion : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static WlRegion()
        {
            NWayland.Protocols.Wayland.WlRegion.WlInterface = new WlInterface("wl_region", 1, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { }),
                new WlMessage("add", "iiii", new WlInterface*[] { null, null, null, null }),
                new WlMessage("subtract", "iiii", new WlInterface*[] { null, null, null, null })
            }, new WlMessage[] { });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlRegion.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        /// <summary>
        /// Add the specified rectangle to the region.<br/><br/>
        /// </summary>
        public void Add(int @x, int @y, int @width, int @height)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                @x,
                @y,
                @width,
                @height
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
        }

        /// <summary>
        /// Subtract the specified rectangle from the region.<br/><br/>
        /// </summary>
        public void Subtract(int @x, int @y, int @width, int @height)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                @x,
                @y,
                @width,
                @height
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 2, __args);
        }

        public interface IEvents
        {
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
        }

        private class ProxyFactory : IBindFactory<WlRegion>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlRegion.WlInterface);
            }

            public WlRegion Create(IntPtr handle, int version)
            {
                return new WlRegion(handle, version);
            }
        }

        public static IBindFactory<WlRegion> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "wl_region";
        public const int InterfaceVersion = 1;

        public WlRegion(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// The global interface exposing sub-surface compositing capabilities.A wl_surface, that has sub-surfaces associated, is called theparent surface. Sub-surfaces can be arbitrarily nested and createa tree of sub-surfaces.<br/><br/>
    /// The root surface in a tree of sub-surfaces is the mainsurface. The main surface cannot be a sub-surface, becausesub-surfaces must always have a parent.<br/><br/>
    /// A main surface with its sub-surfaces forms a (compound) window.For window management purposes, this set of wl_surface objects isto be considered as a single window, and it should also behave assuch.<br/><br/>
    /// The aim of sub-surfaces is to offload some of the compositing workwithin a window from clients to the compositor. A prime example isa video player with decorations and video in separate wl_surfaceobjects. This should allow the compositor to pass YUV video bufferprocessing to dedicated overlay hardware when possible.<br/><br/>
    /// </summary>
    public sealed unsafe partial class WlSubcompositor : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static WlSubcompositor()
        {
            NWayland.Protocols.Wayland.WlSubcompositor.WlInterface = new WlInterface("wl_subcompositor", 1, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { }),
                new WlMessage("get_subsurface", "noo", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSubsurface.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface) })
            }, new WlMessage[] { });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSubcompositor.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        /// <summary>
        /// Create a sub-surface interface for the given surface, andassociate it with the given parent surface. This turns aplain wl_surface into a sub-surface.<br/><br/>
        /// The to-be sub-surface must not already have another role, and itmust not have an existing wl_subsurface object. Otherwise thebad_surface protocol error is raised.<br/><br/>
        /// Adding sub-surfaces to a parent is a double-buffered operation on theparent (see wl_surface.commit). The effect of adding a sub-surfacebecomes visible on the next time the state of the parent surface isapplied.<br/><br/>
        /// The parent surface must not be one of the child surface's descendants,and the parent must be different from the child surface, otherwise thebad_parent protocol error is raised.<br/><br/>
        /// This request modifies the behaviour of wl_surface.commit request onthe sub-surface, see the documentation on wl_subsurface interface.<br/><br/>
        /// </summary>
        public NWayland.Protocols.Wayland.WlSubsurface GetSubsurface(NWayland.Protocols.Wayland.WlSurface @surface, NWayland.Protocols.Wayland.WlSurface @parent)
        {
            if (@parent == null)
                throw new ArgumentNullException("parent");
            if (@surface == null)
                throw new ArgumentNullException("surface");
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId,
                @surface,
                @parent
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 1, __args, ref NWayland.Protocols.Wayland.WlSubsurface.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.Wayland.WlSubsurface(__ret, Version);
        }

        public interface IEvents
        {
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
        }

        public enum ErrorEnum
        {
            /// <summary>
            /// the to-be sub-surface is invalid<br/><br/>
            /// </summary>
            BadSurface = 0,
            /// <summary>
            /// the to-be sub-surface parent is invalid<br/><br/>
            /// </summary>
            BadParent = 1
        }

        private class ProxyFactory : IBindFactory<WlSubcompositor>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSubcompositor.WlInterface);
            }

            public WlSubcompositor Create(IntPtr handle, int version)
            {
                return new WlSubcompositor(handle, version);
            }
        }

        public static IBindFactory<WlSubcompositor> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "wl_subcompositor";
        public const int InterfaceVersion = 1;

        public WlSubcompositor(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// An additional interface to a wl_surface object, which has beenmade a sub-surface. A sub-surface has one parent surface. Asub-surface's size and position are not limited to that of the parent.Particularly, a sub-surface is not automatically clipped to itsparent's area.<br/><br/>
    /// A sub-surface becomes mapped, when a non-NULL wl_buffer is appliedand the parent surface is mapped. The order of which one happensfirst is irrelevant. A sub-surface is hidden if the parent becomeshidden, or if a NULL wl_buffer is applied. These rules applyrecursively through the tree of surfaces.<br/><br/>
    /// The behaviour of a wl_surface.commit request on a sub-surfacedepends on the sub-surface's mode. The possible modes aresynchronized and desynchronized, see methodswl_subsurface.set_sync and wl_subsurface.set_desync. Synchronizedmode caches the wl_surface state to be applied when the parent'sstate gets applied, and desynchronized mode applies the pendingwl_surface state directly. A sub-surface is initially in thesynchronized mode.<br/><br/>
    /// Sub-surfaces also have another kind of state, which is managed bywl_subsurface requests, as opposed to wl_surface requests. Thisstate includes the sub-surface position relative to the parentsurface (wl_subsurface.set_position), and the stacking order ofthe parent and its sub-surfaces (wl_subsurface.place_above and.place_below). This state is applied when the parent surface'swl_surface state is applied, regardless of the sub-surface's mode.As the exception, set_sync and set_desync are effective immediately.<br/><br/>
    /// The main surface can be thought to be always in desynchronized mode,since it does not have a parent in the sub-surfaces sense.<br/><br/>
    /// Even if a sub-surface is in desynchronized mode, it will behave asin synchronized mode, if its parent surface behaves as insynchronized mode. This rule is applied recursively throughout thetree of surfaces. This means, that one can set a sub-surface intosynchronized mode, and then assume that all its child and grand-childsub-surfaces are synchronized, too, without explicitly setting them.<br/><br/>
    /// If the wl_surface associated with the wl_subsurface is destroyed, thewl_subsurface object becomes inert. Note, that destroying either objecttakes effect immediately. If you need to synchronize the removalof a sub-surface to the parent surface update, unmap the sub-surfacefirst by attaching a NULL wl_buffer, update parent, and then destroythe sub-surface.<br/><br/>
    /// If the parent wl_surface object is destroyed, the sub-surface isunmapped.<br/><br/>
    /// </summary>
    public sealed unsafe partial class WlSubsurface : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static WlSubsurface()
        {
            NWayland.Protocols.Wayland.WlSubsurface.WlInterface = new WlInterface("wl_subsurface", 1, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { }),
                new WlMessage("set_position", "ii", new WlInterface*[] { null, null }),
                new WlMessage("place_above", "o", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface) }),
                new WlMessage("place_below", "o", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface) }),
                new WlMessage("set_sync", "", new WlInterface*[] { }),
                new WlMessage("set_desync", "", new WlInterface*[] { })
            }, new WlMessage[] { });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSubsurface.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        /// <summary>
        /// This schedules a sub-surface position change.The sub-surface will be moved so that its origin (top leftcorner pixel) will be at the location x, y of the parent surfacecoordinate system. The coordinates are not restricted to the parentsurface area. Negative values are allowed.<br/><br/>
        /// The scheduled coordinates will take effect whenever the state of theparent surface is applied. When this happens depends on whether theparent surface is in synchronized mode or not. Seewl_subsurface.set_sync and wl_subsurface.set_desync for details.<br/><br/>
        /// If more than one set_position request is invoked by the client beforethe commit of the parent surface, the position of a new request alwaysreplaces the scheduled position from any previous request.<br/><br/>
        /// The initial position is 0, 0.<br/><br/>
        /// </summary>
        public void SetPosition(int @x, int @y)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                @x,
                @y
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
        }

        /// <summary>
        /// This sub-surface is taken from the stack, and put back justabove the reference surface, changing the z-order of the sub-surfaces.The reference surface must be one of the sibling surfaces, or theparent surface. Using any other surface, including this sub-surface,will cause a protocol error.<br/><br/>
        /// The z-order is double-buffered. Requests are handled in order andapplied immediately to a pending state. The final pending state iscopied to the active state the next time the state of the parentsurface is applied. When this happens depends on whether the parentsurface is in synchronized mode or not. See wl_subsurface.set_sync andwl_subsurface.set_desync for details.<br/><br/>
        /// A new sub-surface is initially added as the top-most in the stackof its siblings and parent.<br/><br/>
        /// </summary>
        public void PlaceAbove(NWayland.Protocols.Wayland.WlSurface @sibling)
        {
            if (@sibling == null)
                throw new ArgumentNullException("sibling");
            WlArgument* __args = stackalloc WlArgument[] {
                @sibling
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 2, __args);
        }

        /// <summary>
        /// The sub-surface is placed just below the reference surface.See wl_subsurface.place_above.<br/><br/>
        /// </summary>
        public void PlaceBelow(NWayland.Protocols.Wayland.WlSurface @sibling)
        {
            if (@sibling == null)
                throw new ArgumentNullException("sibling");
            WlArgument* __args = stackalloc WlArgument[] {
                @sibling
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 3, __args);
        }

        /// <summary>
        /// Change the commit behaviour of the sub-surface to synchronizedmode, also described as the parent dependent mode.<br/><br/>
        /// In synchronized mode, wl_surface.commit on a sub-surface willaccumulate the committed state in a cache, but the state willnot be applied and hence will not change the compositor output.The cached state is applied to the sub-surface immediately afterthe parent surface's state is applied. This ensures atomicupdates of the parent and all its synchronized sub-surfaces.Applying the cached state will invalidate the cache, so furtherparent surface commits do not (re-)apply old state.<br/><br/>
        /// See wl_subsurface for the recursive effect of this mode.<br/><br/>
        /// </summary>
        public void SetSync()
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 4, __args);
        }

        /// <summary>
        /// Change the commit behaviour of the sub-surface to desynchronizedmode, also described as independent or freely running mode.<br/><br/>
        /// In desynchronized mode, wl_surface.commit on a sub-surface willapply the pending state directly, without caching, as happensnormally with a wl_surface. Calling wl_surface.commit on theparent surface has no effect on the sub-surface's wl_surfacestate. This mode allows a sub-surface to be updated on its own.<br/><br/>
        /// If cached state exists when wl_surface.commit is called indesynchronized mode, the pending state is added to the cachedstate, and applied as a whole. This invalidates the cache.<br/><br/>
        /// Note: even if a sub-surface is set to desynchronized, a parentsub-surface may override it to behave as synchronized. For details,see wl_subsurface.<br/><br/>
        /// If a surface's parent surface behaves as desynchronized, thenthe cached state is applied on set_desync.<br/><br/>
        /// </summary>
        public void SetDesync()
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 5, __args);
        }

        public interface IEvents
        {
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
        }

        public enum ErrorEnum
        {
            /// <summary>
            /// wl_surface is not a sibling or the parent<br/><br/>
            /// </summary>
            BadSurface = 0
        }

        private class ProxyFactory : IBindFactory<WlSubsurface>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSubsurface.WlInterface);
            }

            public WlSubsurface Create(IntPtr handle, int version)
            {
                return new WlSubsurface(handle, version);
            }
        }

        public static IBindFactory<WlSubsurface> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "wl_subsurface";
        public const int InterfaceVersion = 1;

        public WlSubsurface(IntPtr handle, int version) : base(handle, version)
        {
        }
    }
}