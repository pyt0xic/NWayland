using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using NWayland.Protocols.Wayland;
using NWayland.Interop;
#nullable enable
// <auto-generated/>
namespace NWayland.Protocols.ContentTypeV1
{
    /// <summary>
    /// This interface allows a client to describe the kind of content a surfacewill display, to allow the compositor to optimize its behavior for it.<br/><br/>
    /// Warning! The protocol described in this file is currently in the testingphase. Backward compatible changes may be added together with thecorresponding interface version bump. Backward incompatible changes canonly be done by creating a new major version of the extension.<br/><br/>
    /// </summary>
    public sealed unsafe partial class WpContentTypeManagerV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static WpContentTypeManagerV1()
        {
            NWayland.Protocols.ContentTypeV1.WpContentTypeManagerV1.WlInterface = new WlInterface("wp_content_type_manager_v1", 1, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { }),
                new WlMessage("get_surface_content_type", "no", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.ContentTypeV1.WpContentTypeV1.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface) })
            }, new WlMessage[] { });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.ContentTypeV1.WpContentTypeManagerV1.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        /// <summary>
        /// Create a new content type object associated with the given surface.<br/><br/>
        /// Creating a wp_content_type_v1 from a wl_surface which already has oneattached is a client error: already_constructed.<br/><br/>
        /// </summary>
        public NWayland.Protocols.ContentTypeV1.WpContentTypeV1 GetSurfaceContentType(NWayland.Protocols.Wayland.WlSurface @surface)
        {
            if (@surface == null)
                throw new ArgumentNullException("surface");
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId,
                @surface
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 1, __args, ref NWayland.Protocols.ContentTypeV1.WpContentTypeV1.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.ContentTypeV1.WpContentTypeV1(__ret, Version);
        }

        public interface IEvents
        {
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
        }

        public enum ErrorEnum
        {
            /// <summary>
            /// wl_surface already has a content type object<br/><br/>
            /// </summary>
            AlreadyConstructed = 0
        }

        private class ProxyFactory : IBindFactory<WpContentTypeManagerV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.ContentTypeV1.WpContentTypeManagerV1.WlInterface);
            }

            public WpContentTypeManagerV1 Create(IntPtr handle, int version)
            {
                return new WpContentTypeManagerV1(handle, version);
            }
        }

        public static IBindFactory<WpContentTypeManagerV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "wp_content_type_manager_v1";
        public const int InterfaceVersion = 1;

        public WpContentTypeManagerV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// The content type object allows the compositor to optimize for the kindof content shown on the surface. A compositor may for example use it toset relevant drm properties like "content type".<br/><br/>
    /// The client may request to switch to another content type at any time.When the associated surface gets destroyed, this object becomes inert andthe client should destroy it.<br/><br/>
    /// </summary>
    public sealed unsafe partial class WpContentTypeV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static WpContentTypeV1()
        {
            NWayland.Protocols.ContentTypeV1.WpContentTypeV1.WlInterface = new WlInterface("wp_content_type_v1", 1, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { }),
                new WlMessage("set_content_type", "u", new WlInterface*[] { null })
            }, new WlMessage[] { });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.ContentTypeV1.WpContentTypeV1.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        /// <summary>
        /// Set the surface content type. This informs the compositor that theclient believes it is displaying buffers matching this content type.<br/><br/>
        /// This is purely a hint for the compositor, which can be used to adjustits behavior or hardware settings to fit the presented content best.<br/><br/>
        /// The content type is double-buffered state, see wl_surface.commit fordetails.<br/><br/>
        /// </summary>
        public void SetContentType(TypeEnum @contentType)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                (uint)@contentType
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
        }

        public interface IEvents
        {
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
        }

        /// <summary>
        /// These values describe the available content types for a surface.<br/><br/>
        /// </summary>
        public enum TypeEnum
        {
            None = 0,
            Photo = 1,
            Video = 2,
            Game = 3
        }

        private class ProxyFactory : IBindFactory<WpContentTypeV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.ContentTypeV1.WpContentTypeV1.WlInterface);
            }

            public WpContentTypeV1 Create(IntPtr handle, int version)
            {
                return new WpContentTypeV1(handle, version);
            }
        }

        public static IBindFactory<WpContentTypeV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "wp_content_type_v1";
        public const int InterfaceVersion = 1;

        public WpContentTypeV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }
}