using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using NWayland.Protocols.Wayland;
using NWayland.Interop;
#nullable enable
// <auto-generated/>
namespace NWayland.Protocols.XwaylandShellV1
{
    /// <summary>
    /// xwayland_shell_v1 is a singleton global object thatprovides the ability to create a xwayland_surface_v1 objectfor a given wl_surface.<br/><br/>
    /// This interface is intended to be bound by the Xwayland server.<br/><br/>
    /// A compositor must not allow clients other than Xwayland tobind to this interface. A compositor should hide this globalfrom other clients' wl_registry.A client the compositor does not consider to be an Xwaylandserver attempting to bind this interface will result inan implementation-defined error.<br/><br/>
    /// An Xwayland server that has bound this interface must notset the `WL_SURFACE_ID` atom on a window.<br/><br/>
    /// </summary>
    public sealed unsafe partial class XwaylandShellV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static XwaylandShellV1()
        {
            NWayland.Protocols.XwaylandShellV1.XwaylandShellV1.WlInterface = new WlInterface("xwayland_shell_v1", 1, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { }),
                new WlMessage("get_xwayland_surface", "no", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.XwaylandShellV1.XwaylandSurfaceV1.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface) })
            }, new WlMessage[] { });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.XwaylandShellV1.XwaylandShellV1.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        /// <summary>
        /// Create an xwayland_surface_v1 interface for a given wl_surfaceobject and gives it the xwayland_surface role.It is illegal to create an xwayland_surface_v1 for a wl_surfacewhich already has an assigned role and this will result in the`role` protocol error.<br/><br/>
        /// See the documentation of xwayland_surface_v1 for more detailsabout what an xwayland_surface_v1 is and how it is used.<br/><br/>
        /// </summary>
        public NWayland.Protocols.XwaylandShellV1.XwaylandSurfaceV1 GetXwaylandSurface(NWayland.Protocols.Wayland.WlSurface @surface)
        {
            if (@surface == null)
                throw new ArgumentNullException("surface");
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId,
                @surface
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 1, __args, ref NWayland.Protocols.XwaylandShellV1.XwaylandSurfaceV1.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.XwaylandShellV1.XwaylandSurfaceV1(__ret, Version);
        }

        public interface IEvents
        {
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
        }

        public enum ErrorEnum
        {
            /// <summary>
            /// given wl_surface has another role<br/><br/>
            /// </summary>
            Role = 0
        }

        private class ProxyFactory : IBindFactory<XwaylandShellV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.XwaylandShellV1.XwaylandShellV1.WlInterface);
            }

            public XwaylandShellV1 Create(IntPtr handle, int version)
            {
                return new XwaylandShellV1(handle, version);
            }
        }

        public static IBindFactory<XwaylandShellV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "xwayland_shell_v1";
        public const int InterfaceVersion = 1;

        public XwaylandShellV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// An Xwayland surface is a surface managed by an Xwayland server.It is used for associating surfaces to Xwayland windows.<br/><br/>
    /// The Xwayland server associated with actions in this interface isdetermined by the Wayland client making the request.<br/><br/>
    /// The client must call wl_surface.commit on the corresponding wl_surfacefor the xwayland_surface_v1 state to take effect.<br/><br/>
    /// </summary>
    public sealed unsafe partial class XwaylandSurfaceV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static XwaylandSurfaceV1()
        {
            NWayland.Protocols.XwaylandShellV1.XwaylandSurfaceV1.WlInterface = new WlInterface("xwayland_surface_v1", 1, new WlMessage[] {
                new WlMessage("set_serial", "uu", new WlInterface*[] { null, null }),
                new WlMessage("destroy", "", new WlInterface*[] { })
            }, new WlMessage[] { });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.XwaylandShellV1.XwaylandSurfaceV1.WlInterface);
        }

        /// <summary>
        /// Associates an Xwayland window to a wl_surface.The association state is double-buffered and will be applied atthe time wl_surface.commit of the corresponding wl_surface is called.<br/><br/>
        /// The `serial_lo` and `serial_hi` parameters specify a non-zeromonotonic serial number which is entirely unique and provided by theXwayland server equal to the serial value provided by a client messagewith a message type of the `WL_SURFACE_SERIAL` atom on the X11 windowfor this surface to be associated to.<br/><br/>
        /// The serial value in the `WL_SURFACE_SERIAL` client message is specifiedas having the lo-bits specified in `l[0]` and the hi-bits specifiedin `l[1]`.<br/><br/>
        /// If the serial value provided by `serial_lo` and `serial_hi` is notvalid, the `invalid_serial` protocol error will be raised.<br/><br/>
        /// An X11 window may be associated with multiple surfaces throughout itslifespan. (eg. unmapping and remapping a window).For each wl_surface, this state must not be committed more than once,otherwise the `already_associated` protocol error will be raised.<br/><br/>
        /// </summary>
        public void SetSerial(uint @serialLo, uint @serialHi)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                @serialLo,
                @serialHi
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
        }

        public enum ErrorEnum
        {
            /// <summary>
            /// given wl_surface is already associated with an X11 window<br/><br/>
            /// </summary>
            AlreadyAssociated = 0,
            /// <summary>
            /// serial was not valid<br/><br/>
            /// </summary>
            InvalidSerial = 1
        }

        private class ProxyFactory : IBindFactory<XwaylandSurfaceV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.XwaylandShellV1.XwaylandSurfaceV1.WlInterface);
            }

            public XwaylandSurfaceV1 Create(IntPtr handle, int version)
            {
                return new XwaylandSurfaceV1(handle, version);
            }
        }

        public static IBindFactory<XwaylandSurfaceV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "xwayland_surface_v1";
        public const int InterfaceVersion = 1;

        public XwaylandSurfaceV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }
}