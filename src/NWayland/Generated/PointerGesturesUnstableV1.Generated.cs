using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using NWayland.Protocols.Wayland;
using NWayland.Interop;
#nullable enable
// <auto-generated/>
namespace NWayland.Protocols.PointerGesturesUnstableV1
{
    /// <summary>
    /// A global interface to provide semantic touchpad gestures for a givenpointer.<br/><br/>
    /// Three gestures are currently supported: swipe, pinch, and hold.Pinch and swipe gestures follow a three-stage cycle: begin, update,end, hold gestures follow a two-stage cycle: begin and end. Allgestures are identified by a unique id.<br/><br/>
    /// Warning! The protocol described in this file is experimental andbackward incompatible changes may be made. Backward compatible changesmay be added together with the corresponding interface version bump.Backward incompatible changes are done by bumping the version number inthe protocol and interface names and resetting the interface version.Once the protocol is to be declared stable, the 'z' prefix and theversion number in the protocol and interface names are removed and theinterface version number is reset.<br/><br/>
    /// </summary>
    public sealed unsafe partial class ZwpPointerGesturesV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpPointerGesturesV1()
        {
            NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGesturesV1.WlInterface = new WlInterface("zwp_pointer_gestures_v1", 3, new WlMessage[] {
                new WlMessage("get_swipe_gesture", "no", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGestureSwipeV1.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlPointer.WlInterface) }),
                new WlMessage("get_pinch_gesture", "no", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGesturePinchV1.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlPointer.WlInterface) }),
                new WlMessage("release", "2", new WlInterface*[] { }),
                new WlMessage("get_hold_gesture", "3no", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGestureHoldV1.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlPointer.WlInterface) })
            }, new WlMessage[] { });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGesturesV1.WlInterface);
        }

        /// <summary>
        /// Create a swipe gesture object. See thewl_pointer_gesture_swipe interface for details.<br/><br/>
        /// </summary>
        public NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGestureSwipeV1 GetSwipeGesture(NWayland.Protocols.Wayland.WlPointer @pointer)
        {
            if (@pointer == null)
                throw new ArgumentNullException("pointer");
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId,
                @pointer
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 0, __args, ref NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGestureSwipeV1.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGestureSwipeV1(__ret, Version);
        }

        /// <summary>
        /// Create a pinch gesture object. See thewl_pointer_gesture_pinch interface for details.<br/><br/>
        /// </summary>
        public NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGesturePinchV1 GetPinchGesture(NWayland.Protocols.Wayland.WlPointer @pointer)
        {
            if (@pointer == null)
                throw new ArgumentNullException("pointer");
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId,
                @pointer
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 1, __args, ref NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGesturePinchV1.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGesturePinchV1(__ret, Version);
        }

        protected override void Dispose(bool disposing)
        {
            if (Version < 2)
                return;
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 2, __args);
            base.Dispose(true);
        }

        /// <summary>
        /// Create a hold gesture object. See thewl_pointer_gesture_hold interface for details.<br/><br/>
        /// </summary>
        public NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGestureHoldV1 GetHoldGesture(NWayland.Protocols.Wayland.WlPointer @pointer)
        {
            if (@pointer == null)
                throw new ArgumentNullException("pointer");
            if (Version < 3)
                throw new InvalidOperationException("Request get_hold_gesture is only supported since version 3");
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId,
                @pointer
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 3, __args, ref NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGestureHoldV1.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGestureHoldV1(__ret, Version);
        }

        public interface IEvents
        {
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
        }

        private class ProxyFactory : IBindFactory<ZwpPointerGesturesV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGesturesV1.WlInterface);
            }

            public ZwpPointerGesturesV1 Create(IntPtr handle, int version)
            {
                return new ZwpPointerGesturesV1(handle, version);
            }
        }

        public static IBindFactory<ZwpPointerGesturesV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_pointer_gestures_v1";
        public const int InterfaceVersion = 3;

        public ZwpPointerGesturesV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// A swipe gesture object notifies a client about a multi-finger swipegesture detected on an indirect input device such as a touchpad.The gesture is usually initiated by multiple fingers moving in thesame direction but once initiated the direction may change.The precise conditions of when such a gesture is detected areimplementation-dependent.<br/><br/>
    /// A gesture consists of three stages: begin, update (optional) and end.There cannot be multiple simultaneous hold, pinch or swipe gestures on asame pointer/seat, how compositors prevent these situations isimplementation-dependent.<br/><br/>
    /// A gesture may be cancelled by the compositor or the hardware.Clients should not consider performing permanent or irreversibleactions until the end of a gesture has been received.<br/><br/>
    /// </summary>
    public sealed unsafe partial class ZwpPointerGestureSwipeV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpPointerGestureSwipeV1()
        {
            NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGestureSwipeV1.WlInterface = new WlInterface("zwp_pointer_gesture_swipe_v1", 2, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("begin", "uuou", new WlInterface*[] { null, null, WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface), null }),
                new WlMessage("update", "uff", new WlInterface*[] { null, null, null }),
                new WlMessage("end", "uui", new WlInterface*[] { null, null, null })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGestureSwipeV1.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
            /// <summary>
            /// This event is sent when a multi-finger swipe gesture is detectedon the device.<br/><br/>
            /// </summary>
            void OnBegin(NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGestureSwipeV1 eventSender, uint @serial, uint @time, NWayland.Protocols.Wayland.WlSurface @surface, uint @fingers);

            /// <summary>
            /// This event is sent when a multi-finger swipe gesture changes theposition of the logical center.<br/><br/>
            /// The dx and dy coordinates are relative coordinates of the logicalcenter of the gesture compared to the previous event.<br/><br/>
            /// </summary>
            void OnUpdate(NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGestureSwipeV1 eventSender, uint @time, WlFixed @dx, WlFixed @dy);

            /// <summary>
            /// This event is sent when a multi-finger swipe gesture ceases tobe valid. This may happen when one or more fingers are lifted orthe gesture is cancelled.<br/><br/>
            /// When a gesture is cancelled, the client should undo state changescaused by this gesture. What causes a gesture to be cancelled isimplementation-dependent.<br/><br/>
            /// </summary>
            void OnEnd(NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGestureSwipeV1 eventSender, uint @serial, uint @time, int @cancelled);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnBegin(this, arguments[0].UInt32, arguments[1].UInt32, WlProxy.FromNative<NWayland.Protocols.Wayland.WlSurface>(arguments[2].IntPtr), arguments[3].UInt32);
                    break;
                case 1:
                    Events?.OnUpdate(this, arguments[0].UInt32, arguments[1].WlFixed, arguments[2].WlFixed);
                    break;
                case 2:
                    Events?.OnEnd(this, arguments[0].UInt32, arguments[1].UInt32, arguments[2].Int32);
                    break;
            }
        }

        private class ProxyFactory : IBindFactory<ZwpPointerGestureSwipeV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGestureSwipeV1.WlInterface);
            }

            public ZwpPointerGestureSwipeV1 Create(IntPtr handle, int version)
            {
                return new ZwpPointerGestureSwipeV1(handle, version);
            }
        }

        public static IBindFactory<ZwpPointerGestureSwipeV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_pointer_gesture_swipe_v1";
        public const int InterfaceVersion = 2;

        public ZwpPointerGestureSwipeV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// A pinch gesture object notifies a client about a multi-finger pinchgesture detected on an indirect input device such as a touchpad.The gesture is usually initiated by multiple fingers moving towardseach other or away from each other, or by two or more fingers rotatingaround a logical center of gravity. The precise conditions of whensuch a gesture is detected are implementation-dependent.<br/><br/>
    /// A gesture consists of three stages: begin, update (optional) and end.There cannot be multiple simultaneous hold, pinch or swipe gestures on asame pointer/seat, how compositors prevent these situations isimplementation-dependent.<br/><br/>
    /// A gesture may be cancelled by the compositor or the hardware.Clients should not consider performing permanent or irreversibleactions until the end of a gesture has been received.<br/><br/>
    /// </summary>
    public sealed unsafe partial class ZwpPointerGesturePinchV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpPointerGesturePinchV1()
        {
            NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGesturePinchV1.WlInterface = new WlInterface("zwp_pointer_gesture_pinch_v1", 2, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("begin", "uuou", new WlInterface*[] { null, null, WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface), null }),
                new WlMessage("update", "uffff", new WlInterface*[] { null, null, null, null, null }),
                new WlMessage("end", "uui", new WlInterface*[] { null, null, null })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGesturePinchV1.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
            /// <summary>
            /// This event is sent when a multi-finger pinch gesture is detectedon the device.<br/><br/>
            /// </summary>
            void OnBegin(NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGesturePinchV1 eventSender, uint @serial, uint @time, NWayland.Protocols.Wayland.WlSurface @surface, uint @fingers);

            /// <summary>
            /// This event is sent when a multi-finger pinch gesture changes theposition of the logical center, the rotation or the relative scale.<br/><br/>
            /// The dx and dy coordinates are relative coordinates in thesurface coordinate space of the logical center of the gesture.<br/><br/>
            /// The scale factor is an absolute scale compared to thepointer_gesture_pinch.begin event, e.g. a scale of 2 means the fingersare now twice as far apart as on pointer_gesture_pinch.begin.<br/><br/>
            /// The rotation is the relative angle in degrees clockwise compared to the previouspointer_gesture_pinch.begin or pointer_gesture_pinch.update event.<br/><br/>
            /// </summary>
            void OnUpdate(NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGesturePinchV1 eventSender, uint @time, WlFixed @dx, WlFixed @dy, WlFixed @scale, WlFixed @rotation);

            /// <summary>
            /// This event is sent when a multi-finger pinch gesture ceases tobe valid. This may happen when one or more fingers are lifted orthe gesture is cancelled.<br/><br/>
            /// When a gesture is cancelled, the client should undo state changescaused by this gesture. What causes a gesture to be cancelled isimplementation-dependent.<br/><br/>
            /// </summary>
            void OnEnd(NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGesturePinchV1 eventSender, uint @serial, uint @time, int @cancelled);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnBegin(this, arguments[0].UInt32, arguments[1].UInt32, WlProxy.FromNative<NWayland.Protocols.Wayland.WlSurface>(arguments[2].IntPtr), arguments[3].UInt32);
                    break;
                case 1:
                    Events?.OnUpdate(this, arguments[0].UInt32, arguments[1].WlFixed, arguments[2].WlFixed, arguments[3].WlFixed, arguments[4].WlFixed);
                    break;
                case 2:
                    Events?.OnEnd(this, arguments[0].UInt32, arguments[1].UInt32, arguments[2].Int32);
                    break;
            }
        }

        private class ProxyFactory : IBindFactory<ZwpPointerGesturePinchV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGesturePinchV1.WlInterface);
            }

            public ZwpPointerGesturePinchV1 Create(IntPtr handle, int version)
            {
                return new ZwpPointerGesturePinchV1(handle, version);
            }
        }

        public static IBindFactory<ZwpPointerGesturePinchV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_pointer_gesture_pinch_v1";
        public const int InterfaceVersion = 2;

        public ZwpPointerGesturePinchV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// A hold gesture object notifies a client about a single- ormulti-finger hold gesture detected on an indirect input device such asa touchpad. The gesture is usually initiated by one or more fingersbeing held down without significant movement. The precise conditionsof when such a gesture is detected are implementation-dependent.<br/><br/>
    /// In particular, this gesture may be used to cancel kinetic scrolling.<br/><br/>
    /// A hold gesture consists of two stages: begin and end. Unlike pinch andswipe there is no update stage.There cannot be multiple simultaneous hold, pinch or swipe gestures on asame pointer/seat, how compositors prevent these situations isimplementation-dependent.<br/><br/>
    /// A gesture may be cancelled by the compositor or the hardware.Clients should not consider performing permanent or irreversibleactions until the end of a gesture has been received.<br/><br/>
    /// </summary>
    public sealed unsafe partial class ZwpPointerGestureHoldV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpPointerGestureHoldV1()
        {
            NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGestureHoldV1.WlInterface = new WlInterface("zwp_pointer_gesture_hold_v1", 3, new WlMessage[] {
                new WlMessage("destroy", "3", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("begin", "3uuou", new WlInterface*[] { null, null, WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface), null }),
                new WlMessage("end", "3uui", new WlInterface*[] { null, null, null })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGestureHoldV1.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            if (Version < 3)
                return;
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
            /// <summary>
            /// This event is sent when a hold gesture is detected on the device.<br/><br/>
            /// </summary>
            void OnBegin(NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGestureHoldV1 eventSender, uint @serial, uint @time, NWayland.Protocols.Wayland.WlSurface @surface, uint @fingers);

            /// <summary>
            /// This event is sent when a hold gesture ceases tobe valid. This may happen when the holding fingers are lifted orthe gesture is cancelled, for example if the fingers move past animplementation-defined threshold, the finger count changes or the holdgesture changes into a different type of gesture.<br/><br/>
            /// When a gesture is cancelled, the client may need to undo state changescaused by this gesture. What causes a gesture to be cancelled isimplementation-dependent.<br/><br/>
            /// </summary>
            void OnEnd(NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGestureHoldV1 eventSender, uint @serial, uint @time, int @cancelled);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnBegin(this, arguments[0].UInt32, arguments[1].UInt32, WlProxy.FromNative<NWayland.Protocols.Wayland.WlSurface>(arguments[2].IntPtr), arguments[3].UInt32);
                    break;
                case 1:
                    Events?.OnEnd(this, arguments[0].UInt32, arguments[1].UInt32, arguments[2].Int32);
                    break;
            }
        }

        private class ProxyFactory : IBindFactory<ZwpPointerGestureHoldV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGestureHoldV1.WlInterface);
            }

            public ZwpPointerGestureHoldV1 Create(IntPtr handle, int version)
            {
                return new ZwpPointerGestureHoldV1(handle, version);
            }
        }

        public static IBindFactory<ZwpPointerGestureHoldV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_pointer_gesture_hold_v1";
        public const int InterfaceVersion = 3;

        public ZwpPointerGestureHoldV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }
}