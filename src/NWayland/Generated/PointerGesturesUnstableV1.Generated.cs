using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using NWayland.Protocols.Wayland;
using NWayland.Interop;
#nullable enable
// <auto-generated/>
namespace NWayland.Protocols.PointerGesturesUnstableV1
{
    /// <summary>
    /// A global interface to provide semantic touchpad gestures for a given
    /// pointer.
    /// <br/>
    /// <br/>
    /// Three gestures are currently supported: swipe, pinch, and hold.
    /// Pinch and swipe gestures follow a three-stage cycle: begin, update,
    /// end, hold gestures follow a two-stage cycle: begin and end. All
    /// gestures are identified by a unique id.
    /// <br/>
    /// <br/>
    /// Warning! The protocol described in this file is experimental and
    /// backward incompatible changes may be made. Backward compatible changes
    /// may be added together with the corresponding interface version bump.
    /// Backward incompatible changes are done by bumping the version number in
    /// the protocol and interface names and resetting the interface version.
    /// Once the protocol is to be declared stable, the 'z' prefix and the
    /// version number in the protocol and interface names are removed and the
    /// interface version number is reset.
    /// </summary>
    public sealed unsafe partial class ZwpPointerGesturesV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpPointerGesturesV1()
        {
            NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGesturesV1.WlInterface = new WlInterface("zwp_pointer_gestures_v1", 3, new WlMessage[] {
                new WlMessage("get_swipe_gesture", "no", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGestureSwipeV1.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlPointer.WlInterface) }),
                new WlMessage("get_pinch_gesture", "no", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGesturePinchV1.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlPointer.WlInterface) }),
                new WlMessage("release", "2", new WlInterface*[] { }),
                new WlMessage("get_hold_gesture", "3no", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGestureHoldV1.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlPointer.WlInterface) })
            }, new WlMessage[] { });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGesturesV1.WlInterface);
        }

        /// <summary>
        /// Create a swipe gesture object. See the
        /// wl_pointer_gesture_swipe interface for details.
        /// </summary>
        public NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGestureSwipeV1 GetSwipeGesture(NWayland.Protocols.Wayland.WlPointer @pointer)
        {
            if (@pointer == null)
                throw new ArgumentNullException("pointer");
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId,
                @pointer
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 0, __args, ref NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGestureSwipeV1.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGestureSwipeV1(__ret, Version);
        }

        /// <summary>
        /// Create a pinch gesture object. See the
        /// wl_pointer_gesture_pinch interface for details.
        /// </summary>
        public NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGesturePinchV1 GetPinchGesture(NWayland.Protocols.Wayland.WlPointer @pointer)
        {
            if (@pointer == null)
                throw new ArgumentNullException("pointer");
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId,
                @pointer
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 1, __args, ref NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGesturePinchV1.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGesturePinchV1(__ret, Version);
        }

        protected override void Dispose(bool disposing)
        {
            if (Version < 2)
                return;
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 2, __args);
            base.Dispose(true);
        }

        /// <summary>
        /// Create a hold gesture object. See the
        /// wl_pointer_gesture_hold interface for details.
        /// </summary>
        public NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGestureHoldV1 GetHoldGesture(NWayland.Protocols.Wayland.WlPointer @pointer)
        {
            if (@pointer == null)
                throw new ArgumentNullException("pointer");
            if (Version < 3)
                throw new InvalidOperationException("Request get_hold_gesture is only supported since version 3");
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId,
                @pointer
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 3, __args, ref NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGestureHoldV1.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGestureHoldV1(__ret, Version);
        }

        public interface IEvents
        {
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
        }

        private class ProxyFactory : IBindFactory<ZwpPointerGesturesV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGesturesV1.WlInterface);
            }

            public ZwpPointerGesturesV1 Create(IntPtr handle, int version)
            {
                return new ZwpPointerGesturesV1(handle, version);
            }
        }

        public static IBindFactory<ZwpPointerGesturesV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_pointer_gestures_v1";
        public const int InterfaceVersion = 3;

        public ZwpPointerGesturesV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// A swipe gesture object notifies a client about a multi-finger swipe
    /// gesture detected on an indirect input device such as a touchpad.
    /// The gesture is usually initiated by multiple fingers moving in the
    /// same direction but once initiated the direction may change.
    /// The precise conditions of when such a gesture is detected are
    /// implementation-dependent.
    /// <br/>
    /// <br/>
    /// A gesture consists of three stages: begin, update (optional) and end.
    /// There cannot be multiple simultaneous hold, pinch or swipe gestures on a
    /// same pointer/seat, how compositors prevent these situations is
    /// implementation-dependent.
    /// <br/>
    /// <br/>
    /// A gesture may be cancelled by the compositor or the hardware.
    /// Clients should not consider performing permanent or irreversible
    /// actions until the end of a gesture has been received.
    /// </summary>
    public sealed unsafe partial class ZwpPointerGestureSwipeV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpPointerGestureSwipeV1()
        {
            NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGestureSwipeV1.WlInterface = new WlInterface("zwp_pointer_gesture_swipe_v1", 2, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("begin", "uuou", new WlInterface*[] { null, null, WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface), null }),
                new WlMessage("update", "uff", new WlInterface*[] { null, null, null }),
                new WlMessage("end", "uui", new WlInterface*[] { null, null, null })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGestureSwipeV1.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
            /// <summary>
            /// This event is sent when a multi-finger swipe gesture is detected
            /// on the device.
            /// </summary>
            void OnBegin(NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGestureSwipeV1 eventSender, uint @serial, uint @time, NWayland.Protocols.Wayland.WlSurface @surface, uint @fingers);

            /// <summary>
            /// This event is sent when a multi-finger swipe gesture changes the
            /// position of the logical center.
            /// <br/>
            /// <br/>
            /// The dx and dy coordinates are relative coordinates of the logical
            /// center of the gesture compared to the previous event.
            /// </summary>
            void OnUpdate(NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGestureSwipeV1 eventSender, uint @time, WlFixed @dx, WlFixed @dy);

            /// <summary>
            /// This event is sent when a multi-finger swipe gesture ceases to
            /// be valid. This may happen when one or more fingers are lifted or
            /// the gesture is cancelled.
            /// <br/>
            /// <br/>
            /// When a gesture is cancelled, the client should undo state changes
            /// caused by this gesture. What causes a gesture to be cancelled is
            /// implementation-dependent.
            /// </summary>
            void OnEnd(NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGestureSwipeV1 eventSender, uint @serial, uint @time, int @cancelled);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnBegin(this, arguments[0].UInt32, arguments[1].UInt32, WlProxy.FromNative<NWayland.Protocols.Wayland.WlSurface>(arguments[2].IntPtr), arguments[3].UInt32);
                    break;
                case 1:
                    Events?.OnUpdate(this, arguments[0].UInt32, arguments[1].WlFixed, arguments[2].WlFixed);
                    break;
                case 2:
                    Events?.OnEnd(this, arguments[0].UInt32, arguments[1].UInt32, arguments[2].Int32);
                    break;
            }
        }

        private class ProxyFactory : IBindFactory<ZwpPointerGestureSwipeV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGestureSwipeV1.WlInterface);
            }

            public ZwpPointerGestureSwipeV1 Create(IntPtr handle, int version)
            {
                return new ZwpPointerGestureSwipeV1(handle, version);
            }
        }

        public static IBindFactory<ZwpPointerGestureSwipeV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_pointer_gesture_swipe_v1";
        public const int InterfaceVersion = 2;

        public ZwpPointerGestureSwipeV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// A pinch gesture object notifies a client about a multi-finger pinch
    /// gesture detected on an indirect input device such as a touchpad.
    /// The gesture is usually initiated by multiple fingers moving towards
    /// each other or away from each other, or by two or more fingers rotating
    /// around a logical center of gravity. The precise conditions of when
    /// such a gesture is detected are implementation-dependent.
    /// <br/>
    /// <br/>
    /// A gesture consists of three stages: begin, update (optional) and end.
    /// There cannot be multiple simultaneous hold, pinch or swipe gestures on a
    /// same pointer/seat, how compositors prevent these situations is
    /// implementation-dependent.
    /// <br/>
    /// <br/>
    /// A gesture may be cancelled by the compositor or the hardware.
    /// Clients should not consider performing permanent or irreversible
    /// actions until the end of a gesture has been received.
    /// </summary>
    public sealed unsafe partial class ZwpPointerGesturePinchV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpPointerGesturePinchV1()
        {
            NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGesturePinchV1.WlInterface = new WlInterface("zwp_pointer_gesture_pinch_v1", 2, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("begin", "uuou", new WlInterface*[] { null, null, WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface), null }),
                new WlMessage("update", "uffff", new WlInterface*[] { null, null, null, null, null }),
                new WlMessage("end", "uui", new WlInterface*[] { null, null, null })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGesturePinchV1.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
            /// <summary>
            /// This event is sent when a multi-finger pinch gesture is detected
            /// on the device.
            /// </summary>
            void OnBegin(NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGesturePinchV1 eventSender, uint @serial, uint @time, NWayland.Protocols.Wayland.WlSurface @surface, uint @fingers);

            /// <summary>
            /// This event is sent when a multi-finger pinch gesture changes the
            /// position of the logical center, the rotation or the relative scale.
            /// <br/>
            /// <br/>
            /// The dx and dy coordinates are relative coordinates in the
            /// surface coordinate space of the logical center of the gesture.
            /// <br/>
            /// <br/>
            /// The scale factor is an absolute scale compared to the
            /// pointer_gesture_pinch.begin event, e.g. a scale of 2 means the fingers
            /// are now twice as far apart as on pointer_gesture_pinch.begin.
            /// <br/>
            /// <br/>
            /// The rotation is the relative angle in degrees clockwise compared to the previous
            /// pointer_gesture_pinch.begin or pointer_gesture_pinch.update event.
            /// </summary>
            void OnUpdate(NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGesturePinchV1 eventSender, uint @time, WlFixed @dx, WlFixed @dy, WlFixed @scale, WlFixed @rotation);

            /// <summary>
            /// This event is sent when a multi-finger pinch gesture ceases to
            /// be valid. This may happen when one or more fingers are lifted or
            /// the gesture is cancelled.
            /// <br/>
            /// <br/>
            /// When a gesture is cancelled, the client should undo state changes
            /// caused by this gesture. What causes a gesture to be cancelled is
            /// implementation-dependent.
            /// </summary>
            void OnEnd(NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGesturePinchV1 eventSender, uint @serial, uint @time, int @cancelled);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnBegin(this, arguments[0].UInt32, arguments[1].UInt32, WlProxy.FromNative<NWayland.Protocols.Wayland.WlSurface>(arguments[2].IntPtr), arguments[3].UInt32);
                    break;
                case 1:
                    Events?.OnUpdate(this, arguments[0].UInt32, arguments[1].WlFixed, arguments[2].WlFixed, arguments[3].WlFixed, arguments[4].WlFixed);
                    break;
                case 2:
                    Events?.OnEnd(this, arguments[0].UInt32, arguments[1].UInt32, arguments[2].Int32);
                    break;
            }
        }

        private class ProxyFactory : IBindFactory<ZwpPointerGesturePinchV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGesturePinchV1.WlInterface);
            }

            public ZwpPointerGesturePinchV1 Create(IntPtr handle, int version)
            {
                return new ZwpPointerGesturePinchV1(handle, version);
            }
        }

        public static IBindFactory<ZwpPointerGesturePinchV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_pointer_gesture_pinch_v1";
        public const int InterfaceVersion = 2;

        public ZwpPointerGesturePinchV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// A hold gesture object notifies a client about a single- or
    /// multi-finger hold gesture detected on an indirect input device such as
    /// a touchpad. The gesture is usually initiated by one or more fingers
    /// being held down without significant movement. The precise conditions
    /// of when such a gesture is detected are implementation-dependent.
    /// <br/>
    /// <br/>
    /// In particular, this gesture may be used to cancel kinetic scrolling.
    /// <br/>
    /// <br/>
    /// A hold gesture consists of two stages: begin and end. Unlike pinch and
    /// swipe there is no update stage.
    /// There cannot be multiple simultaneous hold, pinch or swipe gestures on a
    /// same pointer/seat, how compositors prevent these situations is
    /// implementation-dependent.
    /// <br/>
    /// <br/>
    /// A gesture may be cancelled by the compositor or the hardware.
    /// Clients should not consider performing permanent or irreversible
    /// actions until the end of a gesture has been received.
    /// </summary>
    public sealed unsafe partial class ZwpPointerGestureHoldV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpPointerGestureHoldV1()
        {
            NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGestureHoldV1.WlInterface = new WlInterface("zwp_pointer_gesture_hold_v1", 3, new WlMessage[] {
                new WlMessage("destroy", "3", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("begin", "3uuou", new WlInterface*[] { null, null, WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface), null }),
                new WlMessage("end", "3uui", new WlInterface*[] { null, null, null })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGestureHoldV1.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            if (Version < 3)
                return;
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
            /// <summary>
            /// This event is sent when a hold gesture is detected on the device.
            /// </summary>
            void OnBegin(NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGestureHoldV1 eventSender, uint @serial, uint @time, NWayland.Protocols.Wayland.WlSurface @surface, uint @fingers);

            /// <summary>
            /// This event is sent when a hold gesture ceases to
            /// be valid. This may happen when the holding fingers are lifted or
            /// the gesture is cancelled, for example if the fingers move past an
            /// implementation-defined threshold, the finger count changes or the hold
            /// gesture changes into a different type of gesture.
            /// <br/>
            /// <br/>
            /// When a gesture is cancelled, the client may need to undo state changes
            /// caused by this gesture. What causes a gesture to be cancelled is
            /// implementation-dependent.
            /// </summary>
            void OnEnd(NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGestureHoldV1 eventSender, uint @serial, uint @time, int @cancelled);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnBegin(this, arguments[0].UInt32, arguments[1].UInt32, WlProxy.FromNative<NWayland.Protocols.Wayland.WlSurface>(arguments[2].IntPtr), arguments[3].UInt32);
                    break;
                case 1:
                    Events?.OnEnd(this, arguments[0].UInt32, arguments[1].UInt32, arguments[2].Int32);
                    break;
            }
        }

        private class ProxyFactory : IBindFactory<ZwpPointerGestureHoldV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.PointerGesturesUnstableV1.ZwpPointerGestureHoldV1.WlInterface);
            }

            public ZwpPointerGestureHoldV1 Create(IntPtr handle, int version)
            {
                return new ZwpPointerGestureHoldV1(handle, version);
            }
        }

        public static IBindFactory<ZwpPointerGestureHoldV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_pointer_gesture_hold_v1";
        public const int InterfaceVersion = 3;

        public ZwpPointerGestureHoldV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }
}