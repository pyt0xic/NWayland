using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using NWayland.Protocols.Wayland;
using NWayland.Interop;
#nullable enable
// <auto-generated/>
namespace NWayland.Protocols.ExtIdleNotifyV1
{
    /// <summary>
    /// This interface allows clients to monitor user idle status.<br/><br/>
    /// After binding to this global, clients can create ext_idle_notification_v1objects to get notified when the user is idle for a given amount of time.<br/><br/>
    /// </summary>
    public sealed unsafe partial class ExtIdleNotifierV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ExtIdleNotifierV1()
        {
            NWayland.Protocols.ExtIdleNotifyV1.ExtIdleNotifierV1.WlInterface = new WlInterface("ext_idle_notifier_v1", 1, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { }),
                new WlMessage("get_idle_notification", "nuo", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.ExtIdleNotifyV1.ExtIdleNotificationV1.WlInterface), null, WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSeat.WlInterface) })
            }, new WlMessage[] { });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.ExtIdleNotifyV1.ExtIdleNotifierV1.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        /// <summary>
        /// Create a new idle notification object.<br/><br/>
        /// The notification object has a minimum timeout duration and is tied to aseat. The client will be notified if the seat is inactive for at leastthe provided timeout. See ext_idle_notification_v1 for more details.<br/><br/>
        /// A zero timeout is valid and means the client wants to be notified assoon as possible when the seat is inactive.<br/><br/>
        /// </summary>
        public NWayland.Protocols.ExtIdleNotifyV1.ExtIdleNotificationV1 GetIdleNotification(uint @timeout, NWayland.Protocols.Wayland.WlSeat @seat)
        {
            if (@seat == null)
                throw new ArgumentNullException("seat");
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId,
                @timeout,
                @seat
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 1, __args, ref NWayland.Protocols.ExtIdleNotifyV1.ExtIdleNotificationV1.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.ExtIdleNotifyV1.ExtIdleNotificationV1(__ret, Version);
        }

        public interface IEvents
        {
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
        }

        private class ProxyFactory : IBindFactory<ExtIdleNotifierV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.ExtIdleNotifyV1.ExtIdleNotifierV1.WlInterface);
            }

            public ExtIdleNotifierV1 Create(IntPtr handle, int version)
            {
                return new ExtIdleNotifierV1(handle, version);
            }
        }

        public static IBindFactory<ExtIdleNotifierV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "ext_idle_notifier_v1";
        public const int InterfaceVersion = 1;

        public ExtIdleNotifierV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// This interface is used by the compositor to send idle notification eventsto clients.<br/><br/>
    /// Initially the notification object is not idle. The notification objectbecomes idle when no user activity has happened for at least the timeoutduration, starting from the creation of the notification object. Useractivity may include input events or a presence sensor, but iscompositor-specific. If an idle inhibitor is active (e.g. another clienthas created a zwp_idle_inhibitor_v1 on a visible surface), the compositormust not make the notification object idle.<br/><br/>
    /// When the notification object becomes idle, an idled event is sent. Whenuser activity starts again, the notification object stops being idle,a resumed event is sent and the timeout is restarted.<br/><br/>
    /// </summary>
    public sealed unsafe partial class ExtIdleNotificationV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ExtIdleNotificationV1()
        {
            NWayland.Protocols.ExtIdleNotifyV1.ExtIdleNotificationV1.WlInterface = new WlInterface("ext_idle_notification_v1", 1, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("idled", "", new WlInterface*[] { }),
                new WlMessage("resumed", "", new WlInterface*[] { })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.ExtIdleNotifyV1.ExtIdleNotificationV1.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
            /// <summary>
            /// This event is sent when the notification object becomes idle.<br/><br/>
            /// It's a compositor protocol error to send this event twice without aresumed event in-between.<br/><br/>
            /// </summary>
            void OnIdled(NWayland.Protocols.ExtIdleNotifyV1.ExtIdleNotificationV1 eventSender);

            /// <summary>
            /// This event is sent when the notification object stops being idle.<br/><br/>
            /// It's a compositor protocol error to send this event twice without anidled event in-between. It's a compositor protocol error to send thisevent prior to any idled event.<br/><br/>
            /// </summary>
            void OnResumed(NWayland.Protocols.ExtIdleNotifyV1.ExtIdleNotificationV1 eventSender);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnIdled(this);
                    break;
                case 1:
                    Events?.OnResumed(this);
                    break;
            }
        }

        private class ProxyFactory : IBindFactory<ExtIdleNotificationV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.ExtIdleNotifyV1.ExtIdleNotificationV1.WlInterface);
            }

            public ExtIdleNotificationV1 Create(IntPtr handle, int version)
            {
                return new ExtIdleNotificationV1(handle, version);
            }
        }

        public static IBindFactory<ExtIdleNotificationV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "ext_idle_notification_v1";
        public const int InterfaceVersion = 1;

        public ExtIdleNotificationV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }
}