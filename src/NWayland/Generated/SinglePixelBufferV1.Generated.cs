using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using NWayland.Protocols.Wayland;
using NWayland.Interop;
#nullable enable
// <auto-generated/>
namespace NWayland.Protocols.SinglePixelBufferV1
{
    /// <summary>
    /// The wp_single_pixel_buffer_manager_v1 interface is a factory for
    /// single-pixel buffers.
    /// </summary>
    public sealed unsafe partial class WpSinglePixelBufferManagerV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static WpSinglePixelBufferManagerV1()
        {
            NWayland.Protocols.SinglePixelBufferV1.WpSinglePixelBufferManagerV1.WlInterface = new WlInterface("wp_single_pixel_buffer_manager_v1", 1, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { }),
                new WlMessage("create_u32_rgba_buffer", "nuuuu", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlBuffer.WlInterface), null, null, null, null })
            }, new WlMessage[] { });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.SinglePixelBufferV1.WpSinglePixelBufferManagerV1.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        /// <summary>
        /// Create a single-pixel buffer from four 32-bit RGBA values.
        /// <br/>
        /// <br/>
        /// Unless specified in another protocol extension, the RGBA values use
        /// pre-multiplied alpha.
        /// <br/>
        /// <br/>
        /// The width and height of the buffer are 1.
        /// </summary>
        public NWayland.Protocols.Wayland.WlBuffer CreateU32RgbaBuffer(uint @r, uint @g, uint @b, uint @a)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId,
                @r,
                @g,
                @b,
                @a
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 1, __args, ref NWayland.Protocols.Wayland.WlBuffer.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.Wayland.WlBuffer(__ret, Version);
        }

        public interface IEvents
        {
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
        }

        private class ProxyFactory : IBindFactory<WpSinglePixelBufferManagerV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.SinglePixelBufferV1.WpSinglePixelBufferManagerV1.WlInterface);
            }

            public WpSinglePixelBufferManagerV1 Create(IntPtr handle, int version)
            {
                return new WpSinglePixelBufferManagerV1(handle, version);
            }
        }

        public static IBindFactory<WpSinglePixelBufferManagerV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "wp_single_pixel_buffer_manager_v1";
        public const int InterfaceVersion = 1;

        public WpSinglePixelBufferManagerV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }
}