using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using NWayland.Protocols.Wayland;
using NWayland.Interop;
#nullable enable
// <auto-generated/>
namespace NWayland.Protocols.ZwpLinuxExplicitSynchronizationUnstableV1
{
    /// <summary>
    /// This global is a factory interface, allowing clients to requestexplicit synchronization for buffers on a per-surface basis.<br/><br/>
    /// See zwp_linux_surface_synchronization_v1 for more information.<br/><br/>
    /// This interface is derived from Chromium'szcr_linux_explicit_synchronization_v1.<br/><br/>
    /// Warning! The protocol described in this file is experimental andbackward incompatible changes may be made. Backward compatible changesmay be added together with the corresponding interface version bump.Backward incompatible changes are done by bumping the version number inthe protocol and interface names and resetting the interface version.Once the protocol is to be declared stable, the 'z' prefix and theversion number in the protocol and interface names are removed and theinterface version number is reset.<br/><br/>
    /// </summary>
    public sealed unsafe partial class ZwpLinuxExplicitSynchronizationV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpLinuxExplicitSynchronizationV1()
        {
            NWayland.Protocols.ZwpLinuxExplicitSynchronizationUnstableV1.ZwpLinuxExplicitSynchronizationV1.WlInterface = new WlInterface("zwp_linux_explicit_synchronization_v1", 2, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { }),
                new WlMessage("get_synchronization", "no", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.ZwpLinuxExplicitSynchronizationUnstableV1.ZwpLinuxSurfaceSynchronizationV1.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface) })
            }, new WlMessage[] { });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.ZwpLinuxExplicitSynchronizationUnstableV1.ZwpLinuxExplicitSynchronizationV1.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        /// <summary>
        /// Instantiate an interface extension for the given wl_surface to provideexplicit synchronization.<br/><br/>
        /// If the given wl_surface already has an explicit synchronization objectassociated, the synchronization_exists protocol error is raised.<br/><br/>
        /// Graphics APIs, like EGL or Vulkan, that manage the buffer queue andcommits of a wl_surface themselves, are likely to be using thisextension internally. If a client is using such an API for awl_surface, it should not directly use this extension on that surface,to avoid raising a synchronization_exists protocol error.<br/><br/>
        /// </summary>
        public NWayland.Protocols.ZwpLinuxExplicitSynchronizationUnstableV1.ZwpLinuxSurfaceSynchronizationV1 GetSynchronization(NWayland.Protocols.Wayland.WlSurface @surface)
        {
            if (@surface == null)
                throw new ArgumentNullException("surface");
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId,
                @surface
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 1, __args, ref NWayland.Protocols.ZwpLinuxExplicitSynchronizationUnstableV1.ZwpLinuxSurfaceSynchronizationV1.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.ZwpLinuxExplicitSynchronizationUnstableV1.ZwpLinuxSurfaceSynchronizationV1(__ret, Version);
        }

        public interface IEvents
        {
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
        }

        public enum ErrorEnum
        {
            /// <summary>
            /// the surface already has a synchronization object associated<br/><br/>
            /// </summary>
            SynchronizationExists = 0
        }

        private class ProxyFactory : IBindFactory<ZwpLinuxExplicitSynchronizationV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.ZwpLinuxExplicitSynchronizationUnstableV1.ZwpLinuxExplicitSynchronizationV1.WlInterface);
            }

            public ZwpLinuxExplicitSynchronizationV1 Create(IntPtr handle, int version)
            {
                return new ZwpLinuxExplicitSynchronizationV1(handle, version);
            }
        }

        public static IBindFactory<ZwpLinuxExplicitSynchronizationV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_linux_explicit_synchronization_v1";
        public const int InterfaceVersion = 2;

        public ZwpLinuxExplicitSynchronizationV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// This object implements per-surface explicit synchronization.<br/><br/>
    /// Synchronization refers to co-ordination of pipelined operations performedon buffers. Most GPU clients will schedule an asynchronous operation torender to the buffer, then immediately send the buffer to the compositorto be attached to a surface.<br/><br/>
    /// In implicit synchronization, ensuring that the rendering operation iscomplete before the compositor displays the buffer is an implementationdetail handled by either the kernel or userspace graphics driver.<br/><br/>
    /// By contrast, in explicit synchronization, dma_fence objects mark when theasynchronous operations are complete. When submitting a buffer, theclient provides an acquire fence which will be waited on before thecompositor accesses the buffer. The Wayland server, through azwp_linux_buffer_release_v1 object, will inform the client with an eventwhich may be accompanied by a release fence, when the compositor will nolonger access the buffer contents due to the specific commit thatrequested the release event.<br/><br/>
    /// Each surface can be associated with only one object of this interface atany time.<br/><br/>
    /// In version 1 of this interface, explicit synchronization is onlyguaranteed to be supported for buffers created with any version of thewp_linux_dmabuf buffer factory. Version 2 additionally guaranteesexplicit synchronization support for opaque EGL buffers, which is a typeof platform specific buffers described in the EGL_WL_bind_wayland_displayextension. Compositors are free to support explicit synchronization foradditional buffer types.<br/><br/>
    /// </summary>
    public sealed unsafe partial class ZwpLinuxSurfaceSynchronizationV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpLinuxSurfaceSynchronizationV1()
        {
            NWayland.Protocols.ZwpLinuxExplicitSynchronizationUnstableV1.ZwpLinuxSurfaceSynchronizationV1.WlInterface = new WlInterface("zwp_linux_surface_synchronization_v1", 2, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { }),
                new WlMessage("set_acquire_fence", "h", new WlInterface*[] { null }),
                new WlMessage("get_release", "n", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.ZwpLinuxExplicitSynchronizationUnstableV1.ZwpLinuxBufferReleaseV1.WlInterface) })
            }, new WlMessage[] { });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.ZwpLinuxExplicitSynchronizationUnstableV1.ZwpLinuxSurfaceSynchronizationV1.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        /// <summary>
        /// Set the acquire fence that must be signaled before the compositormay sample from the buffer attached with wl_surface.attach. The fenceis a dma_fence kernel object.<br/><br/>
        /// The acquire fence is double-buffered state, and will be applied on thenext wl_surface.commit request for the associated surface. Thus, itapplies only to the buffer that is attached to the surface at committime.<br/><br/>
        /// If the provided fd is not a valid dma_fence fd, then an INVALID_FENCEerror is raised.<br/><br/>
        /// If a fence has already been attached during the same commit cycle, aDUPLICATE_FENCE error is raised.<br/><br/>
        /// If the associated wl_surface was destroyed, a NO_SURFACE error israised.<br/><br/>
        /// If at surface commit time the attached buffer does not support explicitsynchronization, an UNSUPPORTED_BUFFER error is raised.<br/><br/>
        /// If at surface commit time there is no buffer attached, a NO_BUFFERerror is raised.<br/><br/>
        /// </summary>
        public void SetAcquireFence(int @fd)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                @fd
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
        }

        /// <summary>
        /// Create a listener for the release of the buffer attached by theclient with wl_surface.attach. See zwp_linux_buffer_release_v1documentation for more information.<br/><br/>
        /// The release object is double-buffered state, and will be associatedwith the buffer that is attached to the surface at wl_surface.committime.<br/><br/>
        /// If a zwp_linux_buffer_release_v1 object has already been requested forthe surface in the same commit cycle, a DUPLICATE_RELEASE error israised.<br/><br/>
        /// If the associated wl_surface was destroyed, a NO_SURFACE erroris raised.<br/><br/>
        /// If at surface commit time there is no buffer attached, a NO_BUFFERerror is raised.<br/><br/>
        /// </summary>
        public NWayland.Protocols.ZwpLinuxExplicitSynchronizationUnstableV1.ZwpLinuxBufferReleaseV1 GetRelease()
        {
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 2, __args, ref NWayland.Protocols.ZwpLinuxExplicitSynchronizationUnstableV1.ZwpLinuxBufferReleaseV1.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.ZwpLinuxExplicitSynchronizationUnstableV1.ZwpLinuxBufferReleaseV1(__ret, Version);
        }

        public interface IEvents
        {
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
        }

        public enum ErrorEnum
        {
            /// <summary>
            /// the fence specified by the client could not be imported<br/><br/>
            /// </summary>
            InvalidFence = 0,
            /// <summary>
            /// multiple fences added for a single surface commit<br/><br/>
            /// </summary>
            DuplicateFence = 1,
            /// <summary>
            /// multiple releases added for a single surface commit<br/><br/>
            /// </summary>
            DuplicateRelease = 2,
            /// <summary>
            /// the associated wl_surface was destroyed<br/><br/>
            /// </summary>
            NoSurface = 3,
            /// <summary>
            /// the buffer does not support explicit synchronization<br/><br/>
            /// </summary>
            UnsupportedBuffer = 4,
            /// <summary>
            /// no buffer was attached<br/><br/>
            /// </summary>
            NoBuffer = 5
        }

        private class ProxyFactory : IBindFactory<ZwpLinuxSurfaceSynchronizationV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.ZwpLinuxExplicitSynchronizationUnstableV1.ZwpLinuxSurfaceSynchronizationV1.WlInterface);
            }

            public ZwpLinuxSurfaceSynchronizationV1 Create(IntPtr handle, int version)
            {
                return new ZwpLinuxSurfaceSynchronizationV1(handle, version);
            }
        }

        public static IBindFactory<ZwpLinuxSurfaceSynchronizationV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_linux_surface_synchronization_v1";
        public const int InterfaceVersion = 2;

        public ZwpLinuxSurfaceSynchronizationV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// This object is instantiated in response to azwp_linux_surface_synchronization_v1.get_release request.<br/><br/>
    /// It provides an alternative to wl_buffer.release events, providing aunique release from a single wl_surface.commit request. The release eventalso supports explicit synchronization, providing a fence FD for theclient to synchronize against.<br/><br/>
    /// Exactly one event, either a fenced_release or an immediate_release, willbe emitted for the wl_surface.commit request. The compositor can chooserelease by release which event it uses.<br/><br/>
    /// This event does not replace wl_buffer.release events; servers are stillrequired to send those events.<br/><br/>
    /// Once a buffer release object has delivered a 'fenced_release' or an'immediate_release' event it is automatically destroyed.<br/><br/>
    /// </summary>
    public sealed unsafe partial class ZwpLinuxBufferReleaseV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpLinuxBufferReleaseV1()
        {
            NWayland.Protocols.ZwpLinuxExplicitSynchronizationUnstableV1.ZwpLinuxBufferReleaseV1.WlInterface = new WlInterface("zwp_linux_buffer_release_v1", 1, new WlMessage[] { }, new WlMessage[] {
                new WlMessage("fenced_release", "h", new WlInterface*[] { null }),
                new WlMessage("immediate_release", "", new WlInterface*[] { })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.ZwpLinuxExplicitSynchronizationUnstableV1.ZwpLinuxBufferReleaseV1.WlInterface);
        }

        public interface IEvents
        {
            /// <summary>
            /// Sent when the compositor has finalised its usage of the associatedbuffer for the relevant commit, providing a dma_fence which will besignaled when all operations by the compositor on that buffer for thatcommit have finished.<br/><br/>
            /// Once the fence has signaled, and assuming the associated buffer is notpending release from other wl_surface.commit requests, no additionalexplicit or implicit synchronization is required to safely reuse ordestroy the buffer.<br/><br/>
            /// This event destroys the zwp_linux_buffer_release_v1 object.<br/><br/>
            /// </summary>
            void OnFencedRelease(NWayland.Protocols.ZwpLinuxExplicitSynchronizationUnstableV1.ZwpLinuxBufferReleaseV1 eventSender, int @fence);

            /// <summary>
            /// Sent when the compositor has finalised its usage of the associatedbuffer for the relevant commit, and either performed no operationsusing it, or has a guarantee that all its operations on that buffer forthat commit have finished.<br/><br/>
            /// Once this event is received, and assuming the associated buffer is notpending release from other wl_surface.commit requests, no additionalexplicit or implicit synchronization is required to safely reuse ordestroy the buffer.<br/><br/>
            /// This event destroys the zwp_linux_buffer_release_v1 object.<br/><br/>
            /// </summary>
            void OnImmediateRelease(NWayland.Protocols.ZwpLinuxExplicitSynchronizationUnstableV1.ZwpLinuxBufferReleaseV1 eventSender);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnFencedRelease(this, arguments[0].Int32);
                    break;
                case 1:
                    Events?.OnImmediateRelease(this);
                    break;
            }
        }

        private class ProxyFactory : IBindFactory<ZwpLinuxBufferReleaseV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.ZwpLinuxExplicitSynchronizationUnstableV1.ZwpLinuxBufferReleaseV1.WlInterface);
            }

            public ZwpLinuxBufferReleaseV1 Create(IntPtr handle, int version)
            {
                return new ZwpLinuxBufferReleaseV1(handle, version);
            }
        }

        public static IBindFactory<ZwpLinuxBufferReleaseV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_linux_buffer_release_v1";
        public const int InterfaceVersion = 1;

        public ZwpLinuxBufferReleaseV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }
}