using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using NWayland.Protocols.Wayland;
using NWayland.Interop;
#nullable enable
// <auto-generated/>
namespace NWayland.Protocols.TearingControlV1
{
    /// <summary>
    /// For some use cases like games or drawing tablets it can make sense toreduce latency by accepting tearing with the use of asynchronous pageflips. This global is a factory interface, allowing clients to informwhich type of presentation the content of their surfaces is suitable for.<br/><br/>
    /// Graphics APIs like EGL or Vulkan, that manage the buffer queue and commitsof a wl_surface themselves, are likely to be using this extensioninternally. If a client is using such an API for a wl_surface, it shouldnot directly use this extension on that surface, to avoid raising atearing_control_exists protocol error.<br/><br/>
    /// Warning! The protocol described in this file is currently in the testingphase. Backward compatible changes may be added together with thecorresponding interface version bump. Backward incompatible changes canonly be done by creating a new major version of the extension.<br/><br/>
    /// </summary>
    public sealed unsafe partial class WpTearingControlManagerV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static WpTearingControlManagerV1()
        {
            NWayland.Protocols.TearingControlV1.WpTearingControlManagerV1.WlInterface = new WlInterface("wp_tearing_control_manager_v1", 1, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { }),
                new WlMessage("get_tearing_control", "no", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TearingControlV1.WpTearingControlV1.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface) })
            }, new WlMessage[] { });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TearingControlV1.WpTearingControlManagerV1.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        /// <summary>
        /// Instantiate an interface extension for the given wl_surface to requestasynchronous page flips for presentation.<br/><br/>
        /// If the given wl_surface already has a wp_tearing_control_v1 objectassociated, the tearing_control_exists protocol error is raised.<br/><br/>
        /// </summary>
        public NWayland.Protocols.TearingControlV1.WpTearingControlV1 GetTearingControl(NWayland.Protocols.Wayland.WlSurface @surface)
        {
            if (@surface == null)
                throw new ArgumentNullException("surface");
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId,
                @surface
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 1, __args, ref NWayland.Protocols.TearingControlV1.WpTearingControlV1.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.TearingControlV1.WpTearingControlV1(__ret, Version);
        }

        public interface IEvents
        {
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
        }

        public enum ErrorEnum
        {
            /// <summary>
            /// the surface already has a tearing object associated<br/><br/>
            /// </summary>
            TearingControlExists = 0
        }

        private class ProxyFactory : IBindFactory<WpTearingControlManagerV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TearingControlV1.WpTearingControlManagerV1.WlInterface);
            }

            public WpTearingControlManagerV1 Create(IntPtr handle, int version)
            {
                return new WpTearingControlManagerV1(handle, version);
            }
        }

        public static IBindFactory<WpTearingControlManagerV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "wp_tearing_control_manager_v1";
        public const int InterfaceVersion = 1;

        public WpTearingControlManagerV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// An additional interface to a wl_surface object, which allows the clientto hint to the compositor if the content on the surface is suitable forpresentation with tearing.The default presentation hint is vsync. See presentation_hint for moredetails.<br/><br/>
    /// </summary>
    public sealed unsafe partial class WpTearingControlV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static WpTearingControlV1()
        {
            NWayland.Protocols.TearingControlV1.WpTearingControlV1.WlInterface = new WlInterface("wp_tearing_control_v1", 1, new WlMessage[] {
                new WlMessage("set_presentation_hint", "u", new WlInterface*[] { null }),
                new WlMessage("destroy", "", new WlInterface*[] { })
            }, new WlMessage[] { });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TearingControlV1.WpTearingControlV1.WlInterface);
        }

        /// <summary>
        /// Set the presentation hint for the associated wl_surface. This state isdouble-buffered and is applied on the next wl_surface.commit.<br/><br/>
        /// The compositor is free to dynamically respect or ignore this hint basedon various conditions like hardware capabilities, surface state anduser preferences.<br/><br/>
        /// </summary>
        public void SetPresentationHint(PresentationHintEnum @hint)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                (uint)@hint
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
        }

        /// <summary>
        /// This enum provides information for if submitted frames from the clientmay be presented with tearing.<br/><br/>
        /// </summary>
        public enum PresentationHintEnum
        {
            Vsync = 0,
            Async = 1
        }

        private class ProxyFactory : IBindFactory<WpTearingControlV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TearingControlV1.WpTearingControlV1.WlInterface);
            }

            public WpTearingControlV1 Create(IntPtr handle, int version)
            {
                return new WpTearingControlV1(handle, version);
            }
        }

        public static IBindFactory<WpTearingControlV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "wp_tearing_control_v1";
        public const int InterfaceVersion = 1;

        public WpTearingControlV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }
}