using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using NWayland.Protocols.Wayland;
using NWayland.Interop;
#nullable enable
// <auto-generated/>
namespace NWayland.Protocols.PresentationTime
{
    /// <summary>
    /// <br/><br/>
    /// When the final realized presentation time is available, e.g.after a framebuffer flip completes, the requestedpresentation_feedback.presented events are sent. The finalpresentation time can differ from the compositor's predicteddisplay update time and the update's target time, especiallywhen the compositor misses its target vertical blanking period.<br/><br/>
    /// </summary>
    public sealed unsafe partial class WpPresentation : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static WpPresentation()
        {
            NWayland.Protocols.PresentationTime.WpPresentation.WlInterface = new WlInterface("wp_presentation", 1, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { }),
                new WlMessage("feedback", "on", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.PresentationTime.WpPresentationFeedback.WlInterface) })
            }, new WlMessage[] {
                new WlMessage("clock_id", "u", new WlInterface*[] { null })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.PresentationTime.WpPresentation.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        /// <summary>
        /// Request presentation feedback for the current content submissionon the given surface. This creates a new presentation_feedbackobject, which will deliver the feedback information once. Ifmultiple presentation_feedback objects are created for the samesubmission, they will all deliver the same information.<br/><br/>
        /// For details on what information is returned, see thepresentation_feedback interface.<br/><br/>
        /// </summary>
        public NWayland.Protocols.PresentationTime.WpPresentationFeedback Feedback(NWayland.Protocols.Wayland.WlSurface @surface)
        {
            if (@surface == null)
                throw new ArgumentNullException("surface");
            WlArgument* __args = stackalloc WlArgument[] {
                @surface,
                WlArgument.NewId
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 1, __args, ref NWayland.Protocols.PresentationTime.WpPresentationFeedback.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.PresentationTime.WpPresentationFeedback(__ret, Version);
        }

        public interface IEvents
        {
            /// <summary>
            /// This event tells the client in which clock domain thecompositor interprets the timestamps used by the presentationextension. This clock is called the presentation clock.<br/><br/>
            /// The compositor sends this event when the client binds to thepresentation interface. The presentation clock does not changeduring the lifetime of the client connection.<br/><br/>
            /// The clock identifier is platform dependent. On Linux/glibc,the identifier value is one of the clockid_t values acceptedby clock_gettime(). clock_gettime() is defined byPOSIX.1-2001.<br/><br/>
            /// Timestamps in this clock domain are expressed as tv_sec_hi,tv_sec_lo, tv_nsec triples, each component being an unsigned32-bit value. Whole seconds are in tv_sec which is a 64-bitvalue combined from tv_sec_hi and tv_sec_lo, and theadditional fractional part in tv_nsec as nanoseconds. Hence,for valid timestamps tv_nsec must be in [0, 999999999].<br/><br/>
            /// Note that clock_id applies only to the presentation clock,and implies nothing about e.g. the timestamps used in theWayland core protocol input events.<br/><br/>
            /// Compositors should prefer a clock which does not jump and isnot slewed e.g. by NTP. The absolute value of the clock isirrelevant. Precision of one millisecond or better isrecommended. Clients must be able to query the current clockvalue directly, not by asking the compositor.<br/><br/>
            /// </summary>
            void OnClockId(NWayland.Protocols.PresentationTime.WpPresentation eventSender, uint @clkId);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnClockId(this, arguments[0].UInt32);
                    break;
            }
        }

        /// <summary>
        /// These fatal protocol errors may be emitted in response toillegal presentation requests.<br/><br/>
        /// </summary>
        public enum ErrorEnum
        {
            /// <summary>
            /// invalid value in tv_nsec<br/><br/>
            /// </summary>
            InvalidTimestamp = 0,
            /// <summary>
            /// invalid flag<br/><br/>
            /// </summary>
            InvalidFlag = 1
        }

        private class ProxyFactory : IBindFactory<WpPresentation>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.PresentationTime.WpPresentation.WlInterface);
            }

            public WpPresentation Create(IntPtr handle, int version)
            {
                return new WpPresentation(handle, version);
            }
        }

        public static IBindFactory<WpPresentation> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "wp_presentation";
        public const int InterfaceVersion = 1;

        public WpPresentation(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// A presentation_feedback object returns an indication that awl_surface content update has become visible to the user.One object corresponds to one content update submission(wl_surface.commit). There are two possible outcomes: thecontent update is presented to the user, and a presentationtimestamp delivered; or, the user did not see the contentupdate because it was superseded or its surface destroyed,and the content update is discarded.<br/><br/>
    /// Once a presentation_feedback object has delivered a 'presented'or 'discarded' event it is automatically destroyed.<br/><br/>
    /// </summary>
    public sealed unsafe partial class WpPresentationFeedback : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static WpPresentationFeedback()
        {
            NWayland.Protocols.PresentationTime.WpPresentationFeedback.WlInterface = new WlInterface("wp_presentation_feedback", 1, new WlMessage[] { }, new WlMessage[] {
                new WlMessage("sync_output", "o", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlOutput.WlInterface) }),
                new WlMessage("presented", "uuuuuuu", new WlInterface*[] { null, null, null, null, null, null, null }),
                new WlMessage("discarded", "", new WlInterface*[] { })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.PresentationTime.WpPresentationFeedback.WlInterface);
        }

        public interface IEvents
        {
            /// <summary>
            /// As presentation can be synchronized to only one output at atime, this event tells which output it was. This event is onlysent prior to the presented event.<br/><br/>
            /// As clients may bind to the same global wl_output multipletimes, this event is sent for each bound instance that matchesthe synchronized output. If a client has not bound to theright wl_output global at all, this event is not sent.<br/><br/>
            /// </summary>
            void OnSyncOutput(NWayland.Protocols.PresentationTime.WpPresentationFeedback eventSender, NWayland.Protocols.Wayland.WlOutput @output);

            /// <summary>
            /// The associated content update was displayed to the user at theindicated time (tv_sec_hi/lo, tv_nsec). For the interpretation ofthe timestamp, see presentation.clock_id event.<br/><br/>
            /// The timestamp corresponds to the time when the content updateturned into light the first time on the surface's main output.Compositors may approximate this from the framebuffer flipcompletion events from the system, and the latency of thephysical display path if known.<br/><br/>
            /// This event is preceded by all related sync_output eventstelling which output's refresh cycle the feedback correspondsto, i.e. the main output for the surface. Compositors arerecommended to choose the output containing the largest partof the wl_surface, or keeping the output they previouslychose. Having a stable presentation output association helpsclients predict future output refreshes (vblank).<br/><br/>
            /// The 'refresh' argument gives the compositor's prediction of howmany nanoseconds after tv_sec, tv_nsec the very next outputrefresh may occur. This is to further aid clients inpredicting future refreshes, i.e., estimating the timestampstargeting the next few vblanks. If such prediction cannotusefully be done, the argument is zero.<br/><br/>
            /// If the output does not have a constant refresh rate, explicitvideo mode switches excluded, then the refresh argument mustbe zero.<br/><br/>
            /// The 64-bit value combined from seq_hi and seq_lo is the valueof the output's vertical retrace counter when the contentupdate was first scanned out to the display. This value mustbe compatible with the definition of MSC inGLX_OML_sync_control specification. Note, that if the displaypath has a non-zero latency, the time instant specified bythis counter may differ from the timestamp's.<br/><br/>
            /// If the output does not have a concept of vertical retrace or arefresh cycle, or the output device is self-refreshing withouta way to query the refresh count, then the arguments seq_hiand seq_lo must be zero.<br/><br/>
            /// </summary>
            void OnPresented(NWayland.Protocols.PresentationTime.WpPresentationFeedback eventSender, uint @tvSecHi, uint @tvSecLo, uint @tvNsec, uint @refresh, uint @seqHi, uint @seqLo, KindEnum @flags);

            /// <summary>
            /// The content update was never displayed to the user.<br/><br/>
            /// </summary>
            void OnDiscarded(NWayland.Protocols.PresentationTime.WpPresentationFeedback eventSender);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnSyncOutput(this, WlProxy.FromNative<NWayland.Protocols.Wayland.WlOutput>(arguments[0].IntPtr));
                    break;
                case 1:
                    Events?.OnPresented(this, arguments[0].UInt32, arguments[1].UInt32, arguments[2].UInt32, arguments[3].UInt32, arguments[4].UInt32, arguments[5].UInt32, (KindEnum)arguments[6].UInt32);
                    break;
                case 2:
                    Events?.OnDiscarded(this);
                    break;
            }
        }

        /// <summary>
        /// These flags provide information about how the presentation ofthe related content update was done. The intent is to helpclients assess the reliability of the feedback and the visualquality with respect to possible tearing and timings.<br/><br/>
        /// </summary>
        [Flags]
        public enum KindEnum
        {
            Vsync = 0x1,
            HwClock = 0x2,
            HwCompletion = 0x4,
            ZeroCopy = 0x8
        }

        private class ProxyFactory : IBindFactory<WpPresentationFeedback>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.PresentationTime.WpPresentationFeedback.WlInterface);
            }

            public WpPresentationFeedback Create(IntPtr handle, int version)
            {
                return new WpPresentationFeedback(handle, version);
            }
        }

        public static IBindFactory<WpPresentationFeedback> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "wp_presentation_feedback";
        public const int InterfaceVersion = 1;

        public WpPresentationFeedback(IntPtr handle, int version) : base(handle, version)
        {
        }
    }
}