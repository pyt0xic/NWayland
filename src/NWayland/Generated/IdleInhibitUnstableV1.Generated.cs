using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using NWayland.Protocols.Wayland;
using NWayland.Interop;
#nullable enable
// <auto-generated/>
namespace NWayland.Protocols.IdleInhibitUnstableV1
{
    /// <summary>
    /// This interface permits inhibiting the idle behavior such as screenblanking, locking, and screensaving.  The client binds the idle managerglobally, then creates idle-inhibitor objects for each surface.<br/><br/>
    /// Warning! The protocol described in this file is experimental andbackward incompatible changes may be made. Backward compatible changesmay be added together with the corresponding interface version bump.Backward incompatible changes are done by bumping the version number inthe protocol and interface names and resetting the interface version.Once the protocol is to be declared stable, the 'z' prefix and theversion number in the protocol and interface names are removed and theinterface version number is reset.<br/><br/>
    /// </summary>
    public sealed unsafe partial class ZwpIdleInhibitManagerV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpIdleInhibitManagerV1()
        {
            NWayland.Protocols.IdleInhibitUnstableV1.ZwpIdleInhibitManagerV1.WlInterface = new WlInterface("zwp_idle_inhibit_manager_v1", 1, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { }),
                new WlMessage("create_inhibitor", "no", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.IdleInhibitUnstableV1.ZwpIdleInhibitorV1.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface) })
            }, new WlMessage[] { });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.IdleInhibitUnstableV1.ZwpIdleInhibitManagerV1.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        /// <summary>
        /// Create a new inhibitor object associated with the given surface.<br/><br/>
        /// </summary>
        public NWayland.Protocols.IdleInhibitUnstableV1.ZwpIdleInhibitorV1 CreateInhibitor(NWayland.Protocols.Wayland.WlSurface @surface)
        {
            if (@surface == null)
                throw new ArgumentNullException("surface");
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId,
                @surface
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 1, __args, ref NWayland.Protocols.IdleInhibitUnstableV1.ZwpIdleInhibitorV1.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.IdleInhibitUnstableV1.ZwpIdleInhibitorV1(__ret, Version);
        }

        public interface IEvents
        {
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
        }

        private class ProxyFactory : IBindFactory<ZwpIdleInhibitManagerV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.IdleInhibitUnstableV1.ZwpIdleInhibitManagerV1.WlInterface);
            }

            public ZwpIdleInhibitManagerV1 Create(IntPtr handle, int version)
            {
                return new ZwpIdleInhibitManagerV1(handle, version);
            }
        }

        public static IBindFactory<ZwpIdleInhibitManagerV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_idle_inhibit_manager_v1";
        public const int InterfaceVersion = 1;

        public ZwpIdleInhibitManagerV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// An idle inhibitor prevents the output that the associated surface isvisible on from being set to a state where it is not visually usable dueto lack of user interaction (e.g. blanked, dimmed, locked, set to powersave, etc.)  Any screensaver processes are also blocked from displaying.<br/><br/>
    /// If the surface is destroyed, unmapped, becomes occluded, losesvisibility, or otherwise becomes not visually relevant for the user, theidle inhibitor will not be honored by the compositor; if the surfacesubsequently regains visibility the inhibitor takes effect once again.Likewise, the inhibitor isn't honored if the system was already idled atthe time the inhibitor was established, although if the system laterde-idles and re-idles the inhibitor will take effect.<br/><br/>
    /// </summary>
    public sealed unsafe partial class ZwpIdleInhibitorV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpIdleInhibitorV1()
        {
            NWayland.Protocols.IdleInhibitUnstableV1.ZwpIdleInhibitorV1.WlInterface = new WlInterface("zwp_idle_inhibitor_v1", 1, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { })
            }, new WlMessage[] { });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.IdleInhibitUnstableV1.ZwpIdleInhibitorV1.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
        }

        private class ProxyFactory : IBindFactory<ZwpIdleInhibitorV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.IdleInhibitUnstableV1.ZwpIdleInhibitorV1.WlInterface);
            }

            public ZwpIdleInhibitorV1 Create(IntPtr handle, int version)
            {
                return new ZwpIdleInhibitorV1(handle, version);
            }
        }

        public static IBindFactory<ZwpIdleInhibitorV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_idle_inhibitor_v1";
        public const int InterfaceVersion = 1;

        public ZwpIdleInhibitorV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }
}