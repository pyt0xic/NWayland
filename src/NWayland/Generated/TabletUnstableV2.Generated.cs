using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using NWayland.Protocols.Wayland;
using NWayland.Interop;
#nullable enable
// <auto-generated/>
namespace NWayland.Protocols.TabletUnstableV2
{
    /// <summary>
    /// An object that provides access to the graphics tablets available on thissystem. All tablets are associated with a seat, to get access to theactual tablets, use wp_tablet_manager.get_tablet_seat.<br/><br/>
    /// </summary>
    public sealed unsafe partial class ZwpTabletManagerV2 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpTabletManagerV2()
        {
            NWayland.Protocols.TabletUnstableV2.ZwpTabletManagerV2.WlInterface = new WlInterface("zwp_tablet_manager_v2", 1, new WlMessage[] {
                new WlMessage("get_tablet_seat", "no", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletSeatV2.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSeat.WlInterface) }),
                new WlMessage("destroy", "", new WlInterface*[] { })
            }, new WlMessage[] { });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletManagerV2.WlInterface);
        }

        /// <summary>
        /// Get the wp_tablet_seat object for the given seat. This objectprovides access to all graphics tablets in this seat.<br/><br/>
        /// </summary>
        public NWayland.Protocols.TabletUnstableV2.ZwpTabletSeatV2 GetTabletSeat(NWayland.Protocols.Wayland.WlSeat @seat)
        {
            if (@seat == null)
                throw new ArgumentNullException("seat");
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId,
                @seat
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 0, __args, ref NWayland.Protocols.TabletUnstableV2.ZwpTabletSeatV2.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.TabletUnstableV2.ZwpTabletSeatV2(__ret, Version);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
        }

        private class ProxyFactory : IBindFactory<ZwpTabletManagerV2>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletManagerV2.WlInterface);
            }

            public ZwpTabletManagerV2 Create(IntPtr handle, int version)
            {
                return new ZwpTabletManagerV2(handle, version);
            }
        }

        public static IBindFactory<ZwpTabletManagerV2> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_tablet_manager_v2";
        public const int InterfaceVersion = 1;

        public ZwpTabletManagerV2(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// An object that provides access to the graphics tablets available on thisseat. After binding to this interface, the compositor sends a set ofwp_tablet_seat.tablet_added and wp_tablet_seat.tool_added events.<br/><br/>
    /// </summary>
    public sealed unsafe partial class ZwpTabletSeatV2 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpTabletSeatV2()
        {
            NWayland.Protocols.TabletUnstableV2.ZwpTabletSeatV2.WlInterface = new WlInterface("zwp_tablet_seat_v2", 1, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("tablet_added", "n", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletV2.WlInterface) }),
                new WlMessage("tool_added", "n", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2.WlInterface) }),
                new WlMessage("pad_added", "n", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletPadV2.WlInterface) })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletSeatV2.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
            /// <summary>
            /// This event is sent whenever a new tablet becomes available on thisseat. This event only provides the object id of the tablet, anystatic information about the tablet (device name, vid/pid, etc.) issent through the wp_tablet interface.<br/><br/>
            /// </summary>
            void OnTabletAdded(NWayland.Protocols.TabletUnstableV2.ZwpTabletSeatV2 eventSender, ZwpTabletV2 @id);

            /// <summary>
            /// This event is sent whenever a tool that has not previously been usedwith a tablet comes into use. This event only provides the object idof the tool; any static information about the tool (capabilities,type, etc.) is sent through the wp_tablet_tool interface.<br/><br/>
            /// </summary>
            void OnToolAdded(NWayland.Protocols.TabletUnstableV2.ZwpTabletSeatV2 eventSender, ZwpTabletToolV2 @id);

            /// <summary>
            /// This event is sent whenever a new pad is known to the system. Typically,pads are physically attached to tablets and a pad_added event issent immediately after the wp_tablet_seat.tablet_added.However, some standalone pad devices logically attach to tablets atruntime, and the client must wait for wp_tablet_pad.enter to knowthe tablet a pad is attached to.<br/><br/>
            /// This event only provides the object id of the pad. All furtherfeatures (buttons, strips, rings) are sent through the wp_tablet_padinterface.<br/><br/>
            /// </summary>
            void OnPadAdded(NWayland.Protocols.TabletUnstableV2.ZwpTabletSeatV2 eventSender, ZwpTabletPadV2 @id);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnTabletAdded(this, new ZwpTabletV2(arguments[0].IntPtr, Version));
                    break;
                case 1:
                    Events?.OnToolAdded(this, new ZwpTabletToolV2(arguments[0].IntPtr, Version));
                    break;
                case 2:
                    Events?.OnPadAdded(this, new ZwpTabletPadV2(arguments[0].IntPtr, Version));
                    break;
            }
        }

        private class ProxyFactory : IBindFactory<ZwpTabletSeatV2>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletSeatV2.WlInterface);
            }

            public ZwpTabletSeatV2 Create(IntPtr handle, int version)
            {
                return new ZwpTabletSeatV2(handle, version);
            }
        }

        public static IBindFactory<ZwpTabletSeatV2> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_tablet_seat_v2";
        public const int InterfaceVersion = 1;

        public ZwpTabletSeatV2(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// An object that represents a physical tool that has been, or iscurrently in use with a tablet in this seat. Each wp_tablet_toolobject stays valid until the client destroys it; the compositorreuses the wp_tablet_tool object to indicate that the object'srespective physical tool has come into proximity of a tablet again.<br/><br/>
    /// A wp_tablet_tool object's relation to a physical tool depends on thetablet's ability to report serial numbers. If the tablet supportsthis capability, then the object represents a specific physical tooland can be identified even when used on multiple tablets.<br/><br/>
    /// A tablet tool has a number of static characteristics, e.g. tool type,hardware_serial and capabilities. These capabilities are sent in anevent sequence after the wp_tablet_seat.tool_added event before anyactual events from this tool. This initial event sequence isterminated by a wp_tablet_tool.done event.<br/><br/>
    /// Tablet tool events are grouped by wp_tablet_tool.frame events.Any events received before a wp_tablet_tool.frame event should beconsidered part of the same hardware state change.<br/><br/>
    /// </summary>
    public sealed unsafe partial class ZwpTabletToolV2 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpTabletToolV2()
        {
            NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2.WlInterface = new WlInterface("zwp_tablet_tool_v2", 1, new WlMessage[] {
                new WlMessage("set_cursor", "u?oii", new WlInterface*[] { null, WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface), null, null }),
                new WlMessage("destroy", "", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("type", "u", new WlInterface*[] { null }),
                new WlMessage("hardware_serial", "uu", new WlInterface*[] { null, null }),
                new WlMessage("hardware_id_wacom", "uu", new WlInterface*[] { null, null }),
                new WlMessage("capability", "u", new WlInterface*[] { null }),
                new WlMessage("done", "", new WlInterface*[] { }),
                new WlMessage("removed", "", new WlInterface*[] { }),
                new WlMessage("proximity_in", "uoo", new WlInterface*[] { null, WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletV2.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface) }),
                new WlMessage("proximity_out", "", new WlInterface*[] { }),
                new WlMessage("down", "u", new WlInterface*[] { null }),
                new WlMessage("up", "", new WlInterface*[] { }),
                new WlMessage("motion", "ff", new WlInterface*[] { null, null }),
                new WlMessage("pressure", "u", new WlInterface*[] { null }),
                new WlMessage("distance", "u", new WlInterface*[] { null }),
                new WlMessage("tilt", "ff", new WlInterface*[] { null, null }),
                new WlMessage("rotation", "f", new WlInterface*[] { null }),
                new WlMessage("slider", "i", new WlInterface*[] { null }),
                new WlMessage("wheel", "fi", new WlInterface*[] { null, null }),
                new WlMessage("button", "uuu", new WlInterface*[] { null, null, null }),
                new WlMessage("frame", "u", new WlInterface*[] { null })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2.WlInterface);
        }

        /// <summary>
        /// Sets the surface of the cursor used for this tool on the giventablet. This request only takes effect if the tool is in proximityof one of the requesting client's surfaces or the surface parameteris the current pointer surface. If there was a previous surface setwith this request it is replaced. If surface is NULL, the cursorimage is hidden.<br/><br/>
        /// The parameters hotspot_x and hotspot_y define the position of thepointer surface relative to the pointer location. Its top-left corneris always at (x, y) - (hotspot_x, hotspot_y), where (x, y) are thecoordinates of the pointer location, in surface-local coordinates.<br/><br/>
        /// On surface.attach requests to the pointer surface, hotspot_x andhotspot_y are decremented by the x and y parameters passed to therequest. Attach must be confirmed by wl_surface.commit as usual.<br/><br/>
        /// The hotspot can also be updated by passing the currently set pointersurface to this request with new values for hotspot_x and hotspot_y.<br/><br/>
        /// The current and pending input regions of the wl_surface are cleared,and wl_surface.set_input_region is ignored until the wl_surface is nolonger used as the cursor. When the use as a cursor ends, the currentand pending input regions become undefined, and the wl_surface isunmapped.<br/><br/>
        /// This request gives the surface the role of a wp_tablet_tool cursor. Asurface may only ever be used as the cursor surface for onewp_tablet_tool. If the surface already has another role or haspreviously been used as cursor surface for a different tool, aprotocol error is raised.<br/><br/>
        /// </summary>
        public void SetCursor(uint @serial, NWayland.Protocols.Wayland.WlSurface? @surface, int @hotspotX, int @hotspotY)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                @serial,
                @surface,
                @hotspotX,
                @hotspotY
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
            /// <summary>
            /// The tool type is the high-level type of the tool and usually decidesthe interaction expected from this tool.<br/><br/>
            /// This event is sent in the initial burst of events before thewp_tablet_tool.done event.<br/><br/>
            /// </summary>
            void OnType(NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2 eventSender, TypeEnum @toolType);

            /// <summary>
            /// If the physical tool can be identified by a unique 64-bit serialnumber, this event notifies the client of this serial number.<br/><br/>
            /// If multiple tablets are available in the same seat and the tool isuniquely identifiable by the serial number, that tool may movebetween tablets.<br/><br/>
            /// Otherwise, if the tool has no serial number and this event ismissing, the tool is tied to the tablet it first comes intoproximity with. Even if the physical tool is used on multipletablets, separate wp_tablet_tool objects will be created, one pertablet.<br/><br/>
            /// This event is sent in the initial burst of events before thewp_tablet_tool.done event.<br/><br/>
            /// </summary>
            void OnHardwareSerial(NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2 eventSender, uint @hardwareSerialHi, uint @hardwareSerialLo);

            /// <summary>
            /// This event notifies the client of a hardware id available on this tool.<br/><br/>
            /// The hardware id is a device-specific 64-bit id that provides extrainformation about the tool in use, beyond the wl_tool.typeenumeration. The format of the id is specific to tablets made byWacom Inc. For example, the hardware id of a Wacom GripPen (a stylus) is 0x802.<br/><br/>
            /// This event is sent in the initial burst of events before thewp_tablet_tool.done event.<br/><br/>
            /// </summary>
            void OnHardwareIdWacom(NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2 eventSender, uint @hardwareIdHi, uint @hardwareIdLo);

            /// <summary>
            /// This event notifies the client of any capabilities of this tool,beyond the main set of x/y axes and tip up/down detection.<br/><br/>
            /// One event is sent for each extra capability available on this tool.<br/><br/>
            /// This event is sent in the initial burst of events before thewp_tablet_tool.done event.<br/><br/>
            /// </summary>
            void OnCapability(NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2 eventSender, CapabilityEnum @capability);

            /// <summary>
            /// This event signals the end of the initial burst of descriptiveevents. A client may consider the static description of the tool tobe complete and finalize initialization of the tool.<br/><br/>
            /// </summary>
            void OnDone(NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2 eventSender);

            /// <summary>
            /// This event is sent when the tool is removed from the system and willsend no further events. Should the physical tool come back intoproximity later, a new wp_tablet_tool object will be created.<br/><br/>
            /// It is compositor-dependent when a tool is removed. A compositor mayremove a tool on proximity out, tablet removal or any other reason.A compositor may also keep a tool alive until shutdown.<br/><br/>
            /// If the tool is currently in proximity, a proximity_out event will besent before the removed event. See wp_tablet_tool.proximity_out forthe handling of any buttons logically down.<br/><br/>
            /// When this event is received, the client must wp_tablet_tool.destroythe object.<br/><br/>
            /// </summary>
            void OnRemoved(NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2 eventSender);

            /// <summary>
            /// Notification that this tool is focused on a certain surface.<br/><br/>
            /// This event can be received when the tool has moved from one surface toanother, or when the tool has come back into proximity above thesurface.<br/><br/>
            /// If any button is logically down when the tool comes into proximity,the respective button event is sent after the proximity_in event butwithin the same frame as the proximity_in event.<br/><br/>
            /// </summary>
            void OnProximityIn(NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2 eventSender, uint @serial, NWayland.Protocols.TabletUnstableV2.ZwpTabletV2 @tablet, NWayland.Protocols.Wayland.WlSurface @surface);

            /// <summary>
            /// Notification that this tool has either left proximity, or is nolonger focused on a certain surface.<br/><br/>
            /// When the tablet tool leaves proximity of the tablet, button releaseevents are sent for each button that was held down at the time ofleaving proximity. These events are sent before the proximity_outevent but within the same wp_tablet.frame.<br/><br/>
            /// If the tool stays within proximity of the tablet, but the focuschanges from one surface to another, a button release event may notbe sent until the button is actually released or the tool leaves theproximity of the tablet.<br/><br/>
            /// </summary>
            void OnProximityOut(NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2 eventSender);

            /// <summary>
            /// Sent whenever the tablet tool comes in contact with the surface of thetablet.<br/><br/>
            /// If the tool is already in contact with the tablet when entering theinput region, the client owning said region will receive awp_tablet.proximity_in event, followed by a wp_tablet.downevent and a wp_tablet.frame event.<br/><br/>
            /// Note that this event describes logical contact, not physicalcontact. On some devices, a compositor may not consider a tool inlogical contact until a minimum physical pressure threshold isexceeded.<br/><br/>
            /// </summary>
            void OnDown(NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2 eventSender, uint @serial);

            /// <summary>
            /// Sent whenever the tablet tool stops making contact with the surface ofthe tablet, or when the tablet tool moves out of the input regionand the compositor grab (if any) is dismissed.<br/><br/>
            /// If the tablet tool moves out of the input region while in contactwith the surface of the tablet and the compositor does not have anongoing grab on the surface, the client owning said region willreceive a wp_tablet.up event, followed by a wp_tablet.proximity_outevent and a wp_tablet.frame event. If the compositor has an ongoinggrab on this device, this event sequence is sent whenever the grabis dismissed in the future.<br/><br/>
            /// Note that this event describes logical contact, not physicalcontact. On some devices, a compositor may not consider a tool outof logical contact until physical pressure falls below a specificthreshold.<br/><br/>
            /// </summary>
            void OnUp(NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2 eventSender);

            /// <summary>
            /// Sent whenever a tablet tool moves.<br/><br/>
            /// </summary>
            void OnMotion(NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2 eventSender, WlFixed @x, WlFixed @y);

            /// <summary>
            /// Sent whenever the pressure axis on a tool changes. The value of thisevent is normalized to a value between 0 and 65535.<br/><br/>
            /// Note that pressure may be nonzero even when a tool is not in logicalcontact. See the down and up events for more details.<br/><br/>
            /// </summary>
            void OnPressure(NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2 eventSender, uint @pressure);

            /// <summary>
            /// Sent whenever the distance axis on a tool changes. The value of thisevent is normalized to a value between 0 and 65535.<br/><br/>
            /// Note that distance may be nonzero even when a tool is not in logicalcontact. See the down and up events for more details.<br/><br/>
            /// </summary>
            void OnDistance(NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2 eventSender, uint @distance);

            /// <summary>
            /// Sent whenever one or both of the tilt axes on a tool change. Each tiltvalue is in degrees, relative to the z-axis of the tablet.The angle is positive when the top of a tool tilts along thepositive x or y axis.<br/><br/>
            /// </summary>
            void OnTilt(NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2 eventSender, WlFixed @tiltX, WlFixed @tiltY);

            /// <summary>
            /// Sent whenever the z-rotation axis on the tool changes. Therotation value is in degrees clockwise from the tool'slogical neutral position.<br/><br/>
            /// </summary>
            void OnRotation(NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2 eventSender, WlFixed @degrees);

            /// <summary>
            /// Sent whenever the slider position on the tool changes. Thevalue is normalized between -65535 and 65535, with 0 as the logicalneutral position of the slider.<br/><br/>
            /// The slider is available on e.g. the Wacom Airbrush tool.<br/><br/>
            /// </summary>
            void OnSlider(NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2 eventSender, int @position);

            /// <summary>
            /// Sent whenever the wheel on the tool emits an event. This eventcontains two values for the same axis change. The degrees value isin the same orientation as the wl_pointer.vertical_scroll axis. Theclicks value is in discrete logical clicks of the mouse wheel. Thisvalue may be zero if the movement of the wheel was lessthan one logical click.<br/><br/>
            /// Clients should choose either value and avoid mixing degrees andclicks. The compositor may accumulate values smaller than a logicalclick and emulate click events when a certain threshold is met.Thus, wl_tablet_tool.wheel events with non-zero clicks values mayhave different degrees values.<br/><br/>
            /// </summary>
            void OnWheel(NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2 eventSender, WlFixed @degrees, int @clicks);

            /// <summary>
            /// Sent whenever a button on the tool is pressed or released.<br/><br/>
            /// If a button is held down when the tool moves in or out of proximity,button events are generated by the compositor. Seewp_tablet_tool.proximity_in and wp_tablet_tool.proximity_out fordetails.<br/><br/>
            /// </summary>
            void OnButton(NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2 eventSender, uint @serial, uint @button, ButtonStateEnum @state);

            /// <summary>
            /// Marks the end of a series of axis and/or button updates from thetablet. The Wayland protocol requires axis updates to be sentsequentially, however all events within a frame should be consideredone hardware event.<br/><br/>
            /// </summary>
            void OnFrame(NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2 eventSender, uint @time);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnType(this, (TypeEnum)arguments[0].UInt32);
                    break;
                case 1:
                    Events?.OnHardwareSerial(this, arguments[0].UInt32, arguments[1].UInt32);
                    break;
                case 2:
                    Events?.OnHardwareIdWacom(this, arguments[0].UInt32, arguments[1].UInt32);
                    break;
                case 3:
                    Events?.OnCapability(this, (CapabilityEnum)arguments[0].UInt32);
                    break;
                case 4:
                    Events?.OnDone(this);
                    break;
                case 5:
                    Events?.OnRemoved(this);
                    break;
                case 6:
                    Events?.OnProximityIn(this, arguments[0].UInt32, WlProxy.FromNative<NWayland.Protocols.TabletUnstableV2.ZwpTabletV2>(arguments[1].IntPtr), WlProxy.FromNative<NWayland.Protocols.Wayland.WlSurface>(arguments[2].IntPtr));
                    break;
                case 7:
                    Events?.OnProximityOut(this);
                    break;
                case 8:
                    Events?.OnDown(this, arguments[0].UInt32);
                    break;
                case 9:
                    Events?.OnUp(this);
                    break;
                case 10:
                    Events?.OnMotion(this, arguments[0].WlFixed, arguments[1].WlFixed);
                    break;
                case 11:
                    Events?.OnPressure(this, arguments[0].UInt32);
                    break;
                case 12:
                    Events?.OnDistance(this, arguments[0].UInt32);
                    break;
                case 13:
                    Events?.OnTilt(this, arguments[0].WlFixed, arguments[1].WlFixed);
                    break;
                case 14:
                    Events?.OnRotation(this, arguments[0].WlFixed);
                    break;
                case 15:
                    Events?.OnSlider(this, arguments[0].Int32);
                    break;
                case 16:
                    Events?.OnWheel(this, arguments[0].WlFixed, arguments[1].Int32);
                    break;
                case 17:
                    Events?.OnButton(this, arguments[0].UInt32, arguments[1].UInt32, (ButtonStateEnum)arguments[2].UInt32);
                    break;
                case 18:
                    Events?.OnFrame(this, arguments[0].UInt32);
                    break;
            }
        }

        /// <summary>
        /// Describes the physical type of a tool. The physical type of a toolgenerally defines its base usage.<br/><br/>
        /// The mouse tool represents a mouse-shaped tool that is not a relativedevice but bound to the tablet's surface, providing absolutecoordinates.<br/><br/>
        /// The lens tool is a mouse-shaped tool with an attached lens toprovide precision focus.<br/><br/>
        /// </summary>
        public enum TypeEnum
        {
            /// <summary>
            /// Pen<br/><br/>
            /// </summary>
            Pen = 0x140,
            /// <summary>
            /// Eraser<br/><br/>
            /// </summary>
            Eraser = 0x141,
            /// <summary>
            /// Brush<br/><br/>
            /// </summary>
            Brush = 0x142,
            /// <summary>
            /// Pencil<br/><br/>
            /// </summary>
            Pencil = 0x143,
            /// <summary>
            /// Airbrush<br/><br/>
            /// </summary>
            Airbrush = 0x144,
            /// <summary>
            /// Finger<br/><br/>
            /// </summary>
            Finger = 0x145,
            /// <summary>
            /// Mouse<br/><br/>
            /// </summary>
            Mouse = 0x146,
            /// <summary>
            /// Lens<br/><br/>
            /// </summary>
            Lens = 0x147
        }

        /// <summary>
        /// Describes extra capabilities on a tablet.<br/><br/>
        /// Any tool must provide x and y values, extra axes aredevice-specific.<br/><br/>
        /// </summary>
        public enum CapabilityEnum
        {
            /// <summary>
            /// Tilt axes<br/><br/>
            /// </summary>
            Tilt = 1,
            /// <summary>
            /// Pressure axis<br/><br/>
            /// </summary>
            Pressure = 2,
            /// <summary>
            /// Distance axis<br/><br/>
            /// </summary>
            Distance = 3,
            /// <summary>
            /// Z-rotation axis<br/><br/>
            /// </summary>
            Rotation = 4,
            /// <summary>
            /// Slider axis<br/><br/>
            /// </summary>
            Slider = 5,
            /// <summary>
            /// Wheel axis<br/><br/>
            /// </summary>
            Wheel = 6
        }

        /// <summary>
        /// Describes the physical state of a button that produced the button event.<br/><br/>
        /// </summary>
        public enum ButtonStateEnum
        {
            /// <summary>
            /// button is not pressed<br/><br/>
            /// </summary>
            Released = 0,
            /// <summary>
            /// button is pressed<br/><br/>
            /// </summary>
            Pressed = 1
        }

        public enum ErrorEnum
        {
            /// <summary>
            /// given wl_surface has another role<br/><br/>
            /// </summary>
            Role = 0
        }

        private class ProxyFactory : IBindFactory<ZwpTabletToolV2>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletToolV2.WlInterface);
            }

            public ZwpTabletToolV2 Create(IntPtr handle, int version)
            {
                return new ZwpTabletToolV2(handle, version);
            }
        }

        public static IBindFactory<ZwpTabletToolV2> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_tablet_tool_v2";
        public const int InterfaceVersion = 1;

        public ZwpTabletToolV2(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// The wp_tablet interface represents one graphics tablet device. Thetablet interface itself does not generate events; all events aregenerated by wp_tablet_tool objects when in proximity above a tablet.<br/><br/>
    /// A tablet has a number of static characteristics, e.g. device name andpid/vid. These capabilities are sent in an event sequence after thewp_tablet_seat.tablet_added event. This initial event sequence isterminated by a wp_tablet.done event.<br/><br/>
    /// </summary>
    public sealed unsafe partial class ZwpTabletV2 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpTabletV2()
        {
            NWayland.Protocols.TabletUnstableV2.ZwpTabletV2.WlInterface = new WlInterface("zwp_tablet_v2", 1, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("name", "s", new WlInterface*[] { null }),
                new WlMessage("id", "uu", new WlInterface*[] { null, null }),
                new WlMessage("path", "s", new WlInterface*[] { null }),
                new WlMessage("done", "", new WlInterface*[] { }),
                new WlMessage("removed", "", new WlInterface*[] { })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletV2.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
            /// <summary>
            /// This event is sent in the initial burst of events before thewp_tablet.done event.<br/><br/>
            /// </summary>
            void OnName(NWayland.Protocols.TabletUnstableV2.ZwpTabletV2 eventSender, string @name);

            /// <summary>
            /// This event is sent in the initial burst of events before thewp_tablet.done event.<br/><br/>
            /// </summary>
            void OnId(NWayland.Protocols.TabletUnstableV2.ZwpTabletV2 eventSender, uint @vid, uint @pid);

            /// <summary>
            /// A system-specific device path that indicates which device is behindthis wp_tablet. This information may be used to gather additionalinformation about the device, e.g. through libwacom.<br/><br/>
            /// A device may have more than one device path. If so, multiplewp_tablet.path events are sent. A device may be emulated and nothave a device path, and in that case this event will not be sent.<br/><br/>
            /// The format of the path is unspecified, it may be a device node, asysfs path, or some other identifier. It is up to the client toidentify the string provided.<br/><br/>
            /// This event is sent in the initial burst of events before thewp_tablet.done event.<br/><br/>
            /// </summary>
            void OnPath(NWayland.Protocols.TabletUnstableV2.ZwpTabletV2 eventSender, string @path);

            /// <summary>
            /// This event is sent immediately to signal the end of the initialburst of descriptive events. A client may consider the staticdescription of the tablet to be complete and finalize initializationof the tablet.<br/><br/>
            /// </summary>
            void OnDone(NWayland.Protocols.TabletUnstableV2.ZwpTabletV2 eventSender);

            /// <summary>
            /// Sent when the tablet has been removed from the system. When a tabletis removed, some tools may be removed.<br/><br/>
            /// When this event is received, the client must wp_tablet.destroythe object.<br/><br/>
            /// </summary>
            void OnRemoved(NWayland.Protocols.TabletUnstableV2.ZwpTabletV2 eventSender);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnName(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr));
                    break;
                case 1:
                    Events?.OnId(this, arguments[0].UInt32, arguments[1].UInt32);
                    break;
                case 2:
                    Events?.OnPath(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr));
                    break;
                case 3:
                    Events?.OnDone(this);
                    break;
                case 4:
                    Events?.OnRemoved(this);
                    break;
            }
        }

        private class ProxyFactory : IBindFactory<ZwpTabletV2>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletV2.WlInterface);
            }

            public ZwpTabletV2 Create(IntPtr handle, int version)
            {
                return new ZwpTabletV2(handle, version);
            }
        }

        public static IBindFactory<ZwpTabletV2> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_tablet_v2";
        public const int InterfaceVersion = 1;

        public ZwpTabletV2(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// A circular interaction area, such as the touch ring on the Wacom IntuosPro series tablets.<br/><br/>
    /// Events on a ring are logically grouped by the wl_tablet_pad_ring.frameevent.<br/><br/>
    /// </summary>
    public sealed unsafe partial class ZwpTabletPadRingV2 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpTabletPadRingV2()
        {
            NWayland.Protocols.TabletUnstableV2.ZwpTabletPadRingV2.WlInterface = new WlInterface("zwp_tablet_pad_ring_v2", 1, new WlMessage[] {
                new WlMessage("set_feedback", "su", new WlInterface*[] { null, null }),
                new WlMessage("destroy", "", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("source", "u", new WlInterface*[] { null }),
                new WlMessage("angle", "f", new WlInterface*[] { null }),
                new WlMessage("stop", "", new WlInterface*[] { }),
                new WlMessage("frame", "u", new WlInterface*[] { null })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletPadRingV2.WlInterface);
        }

        /// <summary>
        /// Request that the compositor use the provided feedback stringassociated with this ring. This request should be issued immediatelyafter a wp_tablet_pad_group.mode_switch event from the correspondinggroup is received, or whenever the ring is mapped to a differentaction. See wp_tablet_pad_group.mode_switch for more details.<br/><br/>
        /// Clients are encouraged to provide context-aware descriptions forthe actions associated with the ring; compositors may use thisinformation to offer visual feedback about the button layout(eg. on-screen displays).<br/><br/>
        /// The provided string 'description' is a UTF-8 encoded string to beassociated with this ring, and is considered user-visible; generalinternationalization rules apply.<br/><br/>
        /// The serial argument will be that of the lastwp_tablet_pad_group.mode_switch event received for the group of thisring. Requests providing other serials than the most recent one will beignored.<br/><br/>
        /// </summary>
        public void SetFeedback(string @description, uint @serial)
        {
            if (@description == null)
                throw new ArgumentNullException("description");
            using var __marshalled__description = new NWaylandMarshalledString(@description);
            WlArgument* __args = stackalloc WlArgument[] {
                __marshalled__description,
                @serial
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
            /// <summary>
            /// Source information for ring events.<br/><br/>
            /// This event does not occur on its own. It is sent before awp_tablet_pad_ring.frame event and carries the source informationfor all events within that frame.<br/><br/>
            /// The source specifies how this event was generated. If the source iswp_tablet_pad_ring.source.finger, a wp_tablet_pad_ring.stop eventwill be sent when the user lifts the finger off the device.<br/><br/>
            /// This event is optional. If the source is unknown for an interaction,no event is sent.<br/><br/>
            /// </summary>
            void OnSource(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadRingV2 eventSender, SourceEnum @source);

            /// <summary>
            /// Sent whenever the angle on a ring changes.<br/><br/>
            /// The angle is provided in degrees clockwise from the logicalnorth of the ring in the pad's current rotation.<br/><br/>
            /// </summary>
            void OnAngle(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadRingV2 eventSender, WlFixed @degrees);

            /// <summary>
            /// Stop notification for ring events.<br/><br/>
            /// For some wp_tablet_pad_ring.source types, a wp_tablet_pad_ring.stopevent is sent to notify a client that the interaction with the ringhas terminated. This enables the client to implement kinetic scrolling.See the wp_tablet_pad_ring.source documentation for information onwhen this event may be generated.<br/><br/>
            /// Any wp_tablet_pad_ring.angle events with the same source after thisevent should be considered as the start of a new interaction.<br/><br/>
            /// </summary>
            void OnStop(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadRingV2 eventSender);

            /// <summary>
            /// Indicates the end of a set of ring events that logically belongtogether. A client is expected to accumulate the data in all eventswithin the frame before proceeding.<br/><br/>
            /// All wp_tablet_pad_ring events before a wp_tablet_pad_ring.frame event belonglogically together. For example, on termination of a finger interactionon a ring the compositor will send a wp_tablet_pad_ring.source event,a wp_tablet_pad_ring.stop event and a wp_tablet_pad_ring.frame event.<br/><br/>
            /// A wp_tablet_pad_ring.frame event is sent for every logical eventgroup, even if the group only contains a single wp_tablet_pad_ringevent. Specifically, a client may get a sequence: angle, frame,angle, frame, etc.<br/><br/>
            /// </summary>
            void OnFrame(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadRingV2 eventSender, uint @time);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnSource(this, (SourceEnum)arguments[0].UInt32);
                    break;
                case 1:
                    Events?.OnAngle(this, arguments[0].WlFixed);
                    break;
                case 2:
                    Events?.OnStop(this);
                    break;
                case 3:
                    Events?.OnFrame(this, arguments[0].UInt32);
                    break;
            }
        }

        /// <summary>
        /// Describes the source types for ring events. This indicates to theclient how a ring event was physically generated; a client mayadjust the user interface accordingly. For example, eventsfrom a "finger" source may trigger kinetic scrolling.<br/><br/>
        /// </summary>
        public enum SourceEnum
        {
            /// <summary>
            /// finger<br/><br/>
            /// </summary>
            Finger = 1
        }

        private class ProxyFactory : IBindFactory<ZwpTabletPadRingV2>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletPadRingV2.WlInterface);
            }

            public ZwpTabletPadRingV2 Create(IntPtr handle, int version)
            {
                return new ZwpTabletPadRingV2(handle, version);
            }
        }

        public static IBindFactory<ZwpTabletPadRingV2> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_tablet_pad_ring_v2";
        public const int InterfaceVersion = 1;

        public ZwpTabletPadRingV2(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// A linear interaction area, such as the strips found in Wacom Cintiqmodels.<br/><br/>
    /// Events on a strip are logically grouped by the wl_tablet_pad_strip.frameevent.<br/><br/>
    /// </summary>
    public sealed unsafe partial class ZwpTabletPadStripV2 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpTabletPadStripV2()
        {
            NWayland.Protocols.TabletUnstableV2.ZwpTabletPadStripV2.WlInterface = new WlInterface("zwp_tablet_pad_strip_v2", 1, new WlMessage[] {
                new WlMessage("set_feedback", "su", new WlInterface*[] { null, null }),
                new WlMessage("destroy", "", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("source", "u", new WlInterface*[] { null }),
                new WlMessage("position", "u", new WlInterface*[] { null }),
                new WlMessage("stop", "", new WlInterface*[] { }),
                new WlMessage("frame", "u", new WlInterface*[] { null })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletPadStripV2.WlInterface);
        }

        /// <summary>
        /// Requests the compositor to use the provided feedback stringassociated with this strip. This request should be issued immediatelyafter a wp_tablet_pad_group.mode_switch event from the correspondinggroup is received, or whenever the strip is mapped to a differentaction. See wp_tablet_pad_group.mode_switch for more details.<br/><br/>
        /// Clients are encouraged to provide context-aware descriptions forthe actions associated with the strip, and compositors may use thisinformation to offer visual feedback about the button layout(eg. on-screen displays).<br/><br/>
        /// The provided string 'description' is a UTF-8 encoded string to beassociated with this ring, and is considered user-visible; generalinternationalization rules apply.<br/><br/>
        /// The serial argument will be that of the lastwp_tablet_pad_group.mode_switch event received for the group of thisstrip. Requests providing other serials than the most recent one will beignored.<br/><br/>
        /// </summary>
        public void SetFeedback(string @description, uint @serial)
        {
            if (@description == null)
                throw new ArgumentNullException("description");
            using var __marshalled__description = new NWaylandMarshalledString(@description);
            WlArgument* __args = stackalloc WlArgument[] {
                __marshalled__description,
                @serial
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
            /// <summary>
            /// Source information for strip events.<br/><br/>
            /// This event does not occur on its own. It is sent before awp_tablet_pad_strip.frame event and carries the source informationfor all events within that frame.<br/><br/>
            /// The source specifies how this event was generated. If the source iswp_tablet_pad_strip.source.finger, a wp_tablet_pad_strip.stop eventwill be sent when the user lifts their finger off the device.<br/><br/>
            /// This event is optional. If the source is unknown for an interaction,no event is sent.<br/><br/>
            /// </summary>
            void OnSource(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadStripV2 eventSender, SourceEnum @source);

            /// <summary>
            /// Sent whenever the position on a strip changes.<br/><br/>
            /// The position is normalized to a range of [0, 65535], the 0-valuerepresents the top-most and/or left-most position of the strip inthe pad's current rotation.<br/><br/>
            /// </summary>
            void OnPosition(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadStripV2 eventSender, uint @position);

            /// <summary>
            /// Stop notification for strip events.<br/><br/>
            /// For some wp_tablet_pad_strip.source types, a wp_tablet_pad_strip.stopevent is sent to notify a client that the interaction with the striphas terminated. This enables the client to implement kineticscrolling. See the wp_tablet_pad_strip.source documentation forinformation on when this event may be generated.<br/><br/>
            /// Any wp_tablet_pad_strip.position events with the same source after thisevent should be considered as the start of a new interaction.<br/><br/>
            /// </summary>
            void OnStop(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadStripV2 eventSender);

            /// <summary>
            /// Indicates the end of a set of events that represent one logicalhardware strip event. A client is expected to accumulate the datain all events within the frame before proceeding.<br/><br/>
            /// All wp_tablet_pad_strip events before a wp_tablet_pad_strip.frame event belonglogically together. For example, on termination of a finger interactionon a strip the compositor will send a wp_tablet_pad_strip.source event,a wp_tablet_pad_strip.stop event and a wp_tablet_pad_strip.frameevent.<br/><br/>
            /// A wp_tablet_pad_strip.frame event is sent for every logical eventgroup, even if the group only contains a single wp_tablet_pad_stripevent. Specifically, a client may get a sequence: position, frame,position, frame, etc.<br/><br/>
            /// </summary>
            void OnFrame(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadStripV2 eventSender, uint @time);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnSource(this, (SourceEnum)arguments[0].UInt32);
                    break;
                case 1:
                    Events?.OnPosition(this, arguments[0].UInt32);
                    break;
                case 2:
                    Events?.OnStop(this);
                    break;
                case 3:
                    Events?.OnFrame(this, arguments[0].UInt32);
                    break;
            }
        }

        /// <summary>
        /// Describes the source types for strip events. This indicates to theclient how a strip event was physically generated; a client mayadjust the user interface accordingly. For example, eventsfrom a "finger" source may trigger kinetic scrolling.<br/><br/>
        /// </summary>
        public enum SourceEnum
        {
            /// <summary>
            /// finger<br/><br/>
            /// </summary>
            Finger = 1
        }

        private class ProxyFactory : IBindFactory<ZwpTabletPadStripV2>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletPadStripV2.WlInterface);
            }

            public ZwpTabletPadStripV2 Create(IntPtr handle, int version)
            {
                return new ZwpTabletPadStripV2(handle, version);
            }
        }

        public static IBindFactory<ZwpTabletPadStripV2> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_tablet_pad_strip_v2";
        public const int InterfaceVersion = 1;

        public ZwpTabletPadStripV2(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// A pad group describes a distinct (sub)set of buttons, rings and stripspresent in the tablet. The criteria of this grouping is usually positional,eg. if a tablet has buttons on the left and right side, 2 groups will bepresented. The physical arrangement of groups is undisclosed and maychange on the fly.<br/><br/>
    /// Pad groups will announce their features during pad initialization. Betweenthe corresponding wp_tablet_pad.group event and wp_tablet_pad_group.done, thepad group will announce the buttons, rings and strips contained in it,plus the number of supported modes.<br/><br/>
    /// Modes are a mechanism to allow multiple groups of actions for every elementin the pad group. The number of groups and available modes in each ispersistent across device plugs. The current mode is user-switchable, itwill be announced through the wp_tablet_pad_group.mode_switch event bothwhenever it is switched, and after wp_tablet_pad.enter.<br/><br/>
    /// The current mode logically applies to all elements in the pad group,although it is at clients' discretion whether to actually perform differentactions, and/or issue the respective .set_feedback requests to notify thecompositor. See the wp_tablet_pad_group.mode_switch event for more details.<br/><br/>
    /// </summary>
    public sealed unsafe partial class ZwpTabletPadGroupV2 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpTabletPadGroupV2()
        {
            NWayland.Protocols.TabletUnstableV2.ZwpTabletPadGroupV2.WlInterface = new WlInterface("zwp_tablet_pad_group_v2", 1, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("buttons", "a", new WlInterface*[] { null }),
                new WlMessage("ring", "n", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletPadRingV2.WlInterface) }),
                new WlMessage("strip", "n", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletPadStripV2.WlInterface) }),
                new WlMessage("modes", "u", new WlInterface*[] { null }),
                new WlMessage("done", "", new WlInterface*[] { }),
                new WlMessage("mode_switch", "uuu", new WlInterface*[] { null, null, null })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletPadGroupV2.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
            /// <summary>
            /// Sent on wp_tablet_pad_group initialization to announce the availablebuttons in the group. Button indices start at 0, a button may only bein one group at a time.<br/><br/>
            /// This event is first sent in the initial burst of events before thewp_tablet_pad_group.done event.<br/><br/>
            /// Some buttons are reserved by the compositor. These buttons may not beassigned to any wp_tablet_pad_group. Compositors may broadcast thisevent in the case of changes to the mapping of these reserved buttons.If the compositor happens to reserve all buttons in a group, this eventwill be sent with an empty array.<br/><br/>
            /// </summary>
            void OnButtons(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadGroupV2 eventSender, ReadOnlySpan<byte> @buttons);

            /// <summary>
            /// Sent on wp_tablet_pad_group initialization to announce available rings.One event is sent for each ring available on this pad group.<br/><br/>
            /// This event is sent in the initial burst of events before thewp_tablet_pad_group.done event.<br/><br/>
            /// </summary>
            void OnRing(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadGroupV2 eventSender, ZwpTabletPadRingV2 @ring);

            /// <summary>
            /// Sent on wp_tablet_pad initialization to announce available strips.One event is sent for each strip available on this pad group.<br/><br/>
            /// This event is sent in the initial burst of events before thewp_tablet_pad_group.done event.<br/><br/>
            /// </summary>
            void OnStrip(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadGroupV2 eventSender, ZwpTabletPadStripV2 @strip);

            /// <summary>
            /// Sent on wp_tablet_pad_group initialization to announce that the padgroup may switch between modes. A client may use a mode to store aspecific configuration for buttons, rings and strips and use thewl_tablet_pad_group.mode_switch event to toggle between theseconfigurations. Mode indices start at 0.<br/><br/>
            /// Switching modes is compositor-dependent. See thewp_tablet_pad_group.mode_switch event for more details.<br/><br/>
            /// This event is sent in the initial burst of events before thewp_tablet_pad_group.done event. This event is only sent when more thanmore than one mode is available.<br/><br/>
            /// </summary>
            void OnModes(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadGroupV2 eventSender, uint @modes);

            /// <summary>
            /// This event is sent immediately to signal the end of the initialburst of descriptive events. A client may consider the staticdescription of the tablet to be complete and finalize initializationof the tablet group.<br/><br/>
            /// </summary>
            void OnDone(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadGroupV2 eventSender);

            /// <summary>
            /// Notification that the mode was switched.<br/><br/>
            /// A mode applies to all buttons, rings and strips in a groupsimultaneously, but a client is not required to assign different actionsfor each mode. For example, a client may have mode-specific buttonmappings but map the ring to vertical scrolling in all modes. Modeindices start at 0.<br/><br/>
            /// Switching modes is compositor-dependent. The compositor may providevisual cues to the client about the mode, e.g. by toggling LEDs onthe tablet device. Mode-switching may be software-controlled orcontrolled by one or more physical buttons. For example, on a WacomIntuos Pro, the button inside the ring may be assigned to switchbetween modes.<br/><br/>
            /// The compositor will also send this event after wp_tablet_pad.enter oneach group in order to notify of the current mode. Groups that onlyfeature one mode will use mode=0 when emitting this event.<br/><br/>
            /// If a button action in the new mode differs from the action in theprevious mode, the client should immediately issue awp_tablet_pad.set_feedback request for each changed button.<br/><br/>
            /// If a ring or strip action in the new mode differs from the actionin the previous mode, the client should immediately issue awp_tablet_ring.set_feedback or wp_tablet_strip.set_feedback requestfor each changed ring or strip.<br/><br/>
            /// </summary>
            void OnModeSwitch(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadGroupV2 eventSender, uint @time, uint @serial, uint @mode);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnButtons(this, WlArray.SpanFromWlArrayPtr<byte>(arguments[0].IntPtr));
                    break;
                case 1:
                    Events?.OnRing(this, new ZwpTabletPadRingV2(arguments[0].IntPtr, Version));
                    break;
                case 2:
                    Events?.OnStrip(this, new ZwpTabletPadStripV2(arguments[0].IntPtr, Version));
                    break;
                case 3:
                    Events?.OnModes(this, arguments[0].UInt32);
                    break;
                case 4:
                    Events?.OnDone(this);
                    break;
                case 5:
                    Events?.OnModeSwitch(this, arguments[0].UInt32, arguments[1].UInt32, arguments[2].UInt32);
                    break;
            }
        }

        private class ProxyFactory : IBindFactory<ZwpTabletPadGroupV2>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletPadGroupV2.WlInterface);
            }

            public ZwpTabletPadGroupV2 Create(IntPtr handle, int version)
            {
                return new ZwpTabletPadGroupV2(handle, version);
            }
        }

        public static IBindFactory<ZwpTabletPadGroupV2> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_tablet_pad_group_v2";
        public const int InterfaceVersion = 1;

        public ZwpTabletPadGroupV2(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// A pad device is a set of buttons, rings and stripsusually physically present on the tablet device itself. Someexceptions exist where the pad device is physically detached, e.g. theWacom ExpressKey Remote.<br/><br/>
    /// Pad devices have no axes that control the cursor and are generallyauxiliary devices to the tool devices used on the tablet surface.<br/><br/>
    /// A pad device has a number of static characteristics, e.g. the numberof rings. These capabilities are sent in an event sequence after thewp_tablet_seat.pad_added event before any actual events from this pad.This initial event sequence is terminated by a wp_tablet_pad.doneevent.<br/><br/>
    /// All pad features (buttons, rings and strips) are logically divided intogroups and all pads have at least one group. The available groups arenotified through the wp_tablet_pad.group event; the compositor willemit one event per group before emitting wp_tablet_pad.done.<br/><br/>
    /// Groups may have multiple modes. Modes allow clients to map multipleactions to a single pad feature. Only one mode can be active per group,although different groups may have different active modes.<br/><br/>
    /// </summary>
    public sealed unsafe partial class ZwpTabletPadV2 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpTabletPadV2()
        {
            NWayland.Protocols.TabletUnstableV2.ZwpTabletPadV2.WlInterface = new WlInterface("zwp_tablet_pad_v2", 1, new WlMessage[] {
                new WlMessage("set_feedback", "usu", new WlInterface*[] { null, null, null }),
                new WlMessage("destroy", "", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("group", "n", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletPadGroupV2.WlInterface) }),
                new WlMessage("path", "s", new WlInterface*[] { null }),
                new WlMessage("buttons", "u", new WlInterface*[] { null }),
                new WlMessage("done", "", new WlInterface*[] { }),
                new WlMessage("button", "uuu", new WlInterface*[] { null, null, null }),
                new WlMessage("enter", "uoo", new WlInterface*[] { null, WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletV2.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface) }),
                new WlMessage("leave", "uo", new WlInterface*[] { null, WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface) }),
                new WlMessage("removed", "", new WlInterface*[] { })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletPadV2.WlInterface);
        }

        /// <summary>
        /// Requests the compositor to use the provided feedback stringassociated with this button. This request should be issued immediatelyafter a wp_tablet_pad_group.mode_switch event from the correspondinggroup is received, or whenever a button is mapped to a differentaction. See wp_tablet_pad_group.mode_switch for more details.<br/><br/>
        /// Clients are encouraged to provide context-aware descriptions forthe actions associated with each button, and compositors may usethis information to offer visual feedback on the button layout(e.g. on-screen displays).<br/><br/>
        /// Button indices start at 0. Setting the feedback string on a buttonthat is reserved by the compositor (i.e. not belonging to anywp_tablet_pad_group) does not generate an error but the compositoris free to ignore the request.<br/><br/>
        /// The provided string 'description' is a UTF-8 encoded string to beassociated with this ring, and is considered user-visible; generalinternationalization rules apply.<br/><br/>
        /// The serial argument will be that of the lastwp_tablet_pad_group.mode_switch event received for the group of thisbutton. Requests providing other serials than the most recent one willbe ignored.<br/><br/>
        /// </summary>
        public void SetFeedback(uint @button, string @description, uint @serial)
        {
            if (@description == null)
                throw new ArgumentNullException("description");
            using var __marshalled__description = new NWaylandMarshalledString(@description);
            WlArgument* __args = stackalloc WlArgument[] {
                @button,
                __marshalled__description,
                @serial
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
            /// <summary>
            /// Sent on wp_tablet_pad initialization to announce available groups.One event is sent for each pad group available.<br/><br/>
            /// This event is sent in the initial burst of events before thewp_tablet_pad.done event. At least one group will be announced.<br/><br/>
            /// </summary>
            void OnGroup(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadV2 eventSender, ZwpTabletPadGroupV2 @padGroup);

            /// <summary>
            /// A system-specific device path that indicates which device is behindthis wp_tablet_pad. This information may be used to gather additionalinformation about the device, e.g. through libwacom.<br/><br/>
            /// The format of the path is unspecified, it may be a device node, asysfs path, or some other identifier. It is up to the client toidentify the string provided.<br/><br/>
            /// This event is sent in the initial burst of events before thewp_tablet_pad.done event.<br/><br/>
            /// </summary>
            void OnPath(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadV2 eventSender, string @path);

            /// <summary>
            /// Sent on wp_tablet_pad initialization to announce the availablebuttons.<br/><br/>
            /// This event is sent in the initial burst of events before thewp_tablet_pad.done event. This event is only sent when at least onebutton is available.<br/><br/>
            /// </summary>
            void OnButtons(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadV2 eventSender, uint @buttons);

            /// <summary>
            /// This event signals the end of the initial burst of descriptiveevents. A client may consider the static description of the pad tobe complete and finalize initialization of the pad.<br/><br/>
            /// </summary>
            void OnDone(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadV2 eventSender);

            /// <summary>
            /// Sent whenever the physical state of a button changes.<br/><br/>
            /// </summary>
            void OnButton(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadV2 eventSender, uint @time, uint @button, ButtonStateEnum @state);

            /// <summary>
            /// Notification that this pad is focused on the specified surface.<br/><br/>
            /// </summary>
            void OnEnter(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadV2 eventSender, uint @serial, NWayland.Protocols.TabletUnstableV2.ZwpTabletV2 @tablet, NWayland.Protocols.Wayland.WlSurface @surface);

            /// <summary>
            /// Notification that this pad is no longer focused on the specifiedsurface.<br/><br/>
            /// </summary>
            void OnLeave(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadV2 eventSender, uint @serial, NWayland.Protocols.Wayland.WlSurface @surface);

            /// <summary>
            /// Sent when the pad has been removed from the system. When a tabletis removed its pad(s) will be removed too.<br/><br/>
            /// When this event is received, the client must destroy all rings, stripsand groups that were offered by this pad, and issue wp_tablet_pad.destroythe pad itself.<br/><br/>
            /// </summary>
            void OnRemoved(NWayland.Protocols.TabletUnstableV2.ZwpTabletPadV2 eventSender);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnGroup(this, new ZwpTabletPadGroupV2(arguments[0].IntPtr, Version));
                    break;
                case 1:
                    Events?.OnPath(this, Marshal.PtrToStringAnsi(arguments[0].IntPtr));
                    break;
                case 2:
                    Events?.OnButtons(this, arguments[0].UInt32);
                    break;
                case 3:
                    Events?.OnDone(this);
                    break;
                case 4:
                    Events?.OnButton(this, arguments[0].UInt32, arguments[1].UInt32, (ButtonStateEnum)arguments[2].UInt32);
                    break;
                case 5:
                    Events?.OnEnter(this, arguments[0].UInt32, WlProxy.FromNative<NWayland.Protocols.TabletUnstableV2.ZwpTabletV2>(arguments[1].IntPtr), WlProxy.FromNative<NWayland.Protocols.Wayland.WlSurface>(arguments[2].IntPtr));
                    break;
                case 6:
                    Events?.OnLeave(this, arguments[0].UInt32, WlProxy.FromNative<NWayland.Protocols.Wayland.WlSurface>(arguments[1].IntPtr));
                    break;
                case 7:
                    Events?.OnRemoved(this);
                    break;
            }
        }

        /// <summary>
        /// Describes the physical state of a button that caused the buttonevent.<br/><br/>
        /// </summary>
        public enum ButtonStateEnum
        {
            /// <summary>
            /// the button is not pressed<br/><br/>
            /// </summary>
            Released = 0,
            /// <summary>
            /// the button is pressed<br/><br/>
            /// </summary>
            Pressed = 1
        }

        private class ProxyFactory : IBindFactory<ZwpTabletPadV2>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.TabletUnstableV2.ZwpTabletPadV2.WlInterface);
            }

            public ZwpTabletPadV2 Create(IntPtr handle, int version)
            {
                return new ZwpTabletPadV2(handle, version);
            }
        }

        public static IBindFactory<ZwpTabletPadV2> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_tablet_pad_v2";
        public const int InterfaceVersion = 1;

        public ZwpTabletPadV2(IntPtr handle, int version) : base(handle, version)
        {
        }
    }
}