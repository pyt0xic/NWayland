using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using NWayland.Protocols.Wayland;
using NWayland.Interop;
#nullable enable
// <auto-generated/>
namespace NWayland.Protocols.FullscreenShellUnstableV1
{
    /// <summary>
    /// Displays a single surface per output.<br/><br/>
    /// This interface provides a mechanism for a single client to displaysimple full-screen surfaces.  While there technically may be multipleclients bound to this interface, only one of those clients should beshown at a time.<br/><br/>
    /// To present a surface, the client uses either the present_surface orpresent_surface_for_mode requests.  Presenting a surface takes effecton the next wl_surface.commit.  See the individual requests fordetails about scaling and mode switches.<br/><br/>
    /// The client can have at most one surface per output at any time.Requesting a surface to be presented on an output that already has asurface replaces the previously presented surface.  Presenting a nullsurface removes its content and effectively disables the output.Exactly what happens when an output is "disabled" iscompositor-specific.  The same surface may be presented on multipleoutputs simultaneously.<br/><br/>
    /// Once a surface is presented on an output, it stays on that outputuntil either the client removes it or the compositor destroys theoutput.  This way, the client can update the output's contents bysimply attaching a new buffer.<br/><br/>
    /// Warning! The protocol described in this file is experimental andbackward incompatible changes may be made. Backward compatible changesmay be added together with the corresponding interface version bump.Backward incompatible changes are done by bumping the version number inthe protocol and interface names and resetting the interface version.Once the protocol is to be declared stable, the 'z' prefix and theversion number in the protocol and interface names are removed and theinterface version number is reset.<br/><br/>
    /// </summary>
    public sealed unsafe partial class ZwpFullscreenShellV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpFullscreenShellV1()
        {
            NWayland.Protocols.FullscreenShellUnstableV1.ZwpFullscreenShellV1.WlInterface = new WlInterface("zwp_fullscreen_shell_v1", 1, new WlMessage[] {
                new WlMessage("release", "", new WlInterface*[] { }),
                new WlMessage("present_surface", "?ou?o", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface), null, WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlOutput.WlInterface) }),
                new WlMessage("present_surface_for_mode", "ooin", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlOutput.WlInterface), null, WlInterface.GeneratorAddressOf(ref NWayland.Protocols.FullscreenShellUnstableV1.ZwpFullscreenShellModeFeedbackV1.WlInterface) })
            }, new WlMessage[] {
                new WlMessage("capability", "u", new WlInterface*[] { null })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.FullscreenShellUnstableV1.ZwpFullscreenShellV1.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        /// <summary>
        /// Present a surface on the given output.<br/><br/>
        /// If the output is null, the compositor will present the surface onwhatever display (or displays) it thinks best.  In particular, thismay replace any or all surfaces currently presented so it shouldnot be used in combination with placing surfaces on specificoutputs.<br/><br/>
        /// The method parameter is a hint to the compositor for how the surfaceis to be presented.  In particular, it tells the compositor how tohandle a size mismatch between the presented surface and theoutput.  The compositor is free to ignore this parameter.<br/><br/>
        /// The "zoom", "zoom_crop", and "stretch" methods imply a scalingoperation on the surface.  This will override any kind of outputscaling, so the buffer_scale property of the surface is effectivelyignored.<br/><br/>
        /// This request gives the surface the role of a fullscreen shell surface.If the surface already has another role, it raises a role protocolerror.<br/><br/>
        /// </summary>
        public void PresentSurface(NWayland.Protocols.Wayland.WlSurface? @surface, PresentMethodEnum @method, NWayland.Protocols.Wayland.WlOutput? @output)
        {
            WlArgument* __args = stackalloc WlArgument[] {
                @surface,
                (uint)@method,
                @output
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 1, __args);
        }

        /// <summary>
        /// Presents a surface on the given output for a particular mode.<br/><br/>
        /// If the current size of the output differs from that of the surface,the compositor will attempt to change the size of the output tomatch the surface.  The result of the mode-switch operation will bereturned via the provided wl_fullscreen_shell_mode_feedback object.<br/><br/>
        /// If the current output mode matches the one requested or if thecompositor successfully switches the mode to match the surface,then the mode_successful event will be sent and the output willcontain the contents of the given surface.  If the compositorcannot match the output size to the surface size, the mode_failedwill be sent and the output will contain the contents of thepreviously presented surface (if any).  If another surface ispresented on the given output before either of these has a chanceto happen, the present_cancelled event will be sent.<br/><br/>
        /// Due to race conditions and other issues unknown to the client, nomode-switch operation is guaranteed to succeed.  However, if themode is one advertised by wl_output.mode or if the compositoradvertises the ARBITRARY_MODES capability, then the client shouldexpect that the mode-switch operation will usually succeed.<br/><br/>
        /// If the size of the presented surface changes, the resulting outputis undefined.  The compositor may attempt to change the output modeto compensate.  However, there is no guarantee that a suitable modewill be found and the client has no way to be notified of successor failure.<br/><br/>
        /// The framerate parameter specifies the desired framerate for theoutput in mHz.  The compositor is free to ignore this parameter.  Avalue of 0 indicates that the client has no preference.<br/><br/>
        /// If the value of wl_output.scale differs from wl_surface.buffer_scale,then the compositor may choose a mode that matches either the buffersize or the surface size.  In either case, the surface will fill theoutput.<br/><br/>
        /// This request gives the surface the role of a fullscreen shell surface.If the surface already has another role, it raises a role protocolerror.<br/><br/>
        /// </summary>
        public NWayland.Protocols.FullscreenShellUnstableV1.ZwpFullscreenShellModeFeedbackV1 PresentSurfaceForMode(NWayland.Protocols.Wayland.WlSurface @surface, NWayland.Protocols.Wayland.WlOutput @output, int @framerate)
        {
            if (@output == null)
                throw new ArgumentNullException("output");
            if (@surface == null)
                throw new ArgumentNullException("surface");
            WlArgument* __args = stackalloc WlArgument[] {
                @surface,
                @output,
                @framerate,
                WlArgument.NewId
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 2, __args, ref NWayland.Protocols.FullscreenShellUnstableV1.ZwpFullscreenShellModeFeedbackV1.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.FullscreenShellUnstableV1.ZwpFullscreenShellModeFeedbackV1(__ret, Version);
        }

        public interface IEvents
        {
            /// <summary>
            /// Advertises a single capability of the compositor.<br/><br/>
            /// When the wl_fullscreen_shell interface is bound, this event is emittedonce for each capability advertised.  Valid capabilities are given bythe wl_fullscreen_shell.capability enum.  If clients want to takeadvantage of any of these capabilities, they should use awl_display.sync request immediately after binding to ensure that theyreceive all the capability events.<br/><br/>
            /// </summary>
            void OnCapability(NWayland.Protocols.FullscreenShellUnstableV1.ZwpFullscreenShellV1 eventSender, CapabilityEnum @capability);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnCapability(this, (CapabilityEnum)arguments[0].UInt32);
                    break;
            }
        }

        /// <summary>
        /// Various capabilities that can be advertised by the compositor.  Theyare advertised one-at-a-time when the wl_fullscreen_shell interface isbound.  See the wl_fullscreen_shell.capability event for more details.<br/><br/>
        /// ARBITRARY_MODES:This is a hint to the client that indicates that the compositor iscapable of setting practically any mode on its outputs.  If thiscapability is provided, wl_fullscreen_shell.present_surface_for_modewill almost never fail and clients should feel free to set whatevermode they like.  If the compositor does not advertise this, it maystill support some modes that are not advertised through wl_global.modebut it is less likely.<br/><br/>
        /// CURSOR_PLANE:This is a hint to the client that indicates that the compositor canhandle a cursor surface from the client without actually compositing.This may be because of a hardware cursor plane or some other mechanism.If the compositor does not advertise this capability then settingwl_pointer.cursor may degrade performance or be ignored entirely.  IfCURSOR_PLANE is not advertised, it is recommended that the client drawits own cursor and set wl_pointer.cursor(NULL).<br/><br/>
        /// </summary>
        public enum CapabilityEnum
        {
            /// <summary>
            /// compositor is capable of almost any output mode<br/><br/>
            /// </summary>
            ArbitraryModes = 1,
            /// <summary>
            /// compositor has a separate cursor plane<br/><br/>
            /// </summary>
            CursorPlane = 2
        }

        /// <summary>
        /// Hints to indicate to the compositor how to deal with a conflictbetween the dimensions of the surface and the dimensions of theoutput. The compositor is free to ignore this parameter.<br/><br/>
        /// </summary>
        public enum PresentMethodEnum
        {
            /// <summary>
            /// no preference, apply default policy<br/><br/>
            /// </summary>
            Default = 0,
            /// <summary>
            /// center the surface on the output<br/><br/>
            /// </summary>
            Center = 1,
            /// <summary>
            /// scale the surface, preserving aspect ratio, to the largest size that will fit on the output<br/><br/>
            /// </summary>
            Zoom = 2,
            /// <summary>
            /// scale the surface, preserving aspect ratio, to fully fill the output cropping if needed<br/><br/>
            /// </summary>
            ZoomCrop = 3,
            /// <summary>
            /// scale the surface to the size of the output ignoring aspect ratio<br/><br/>
            /// </summary>
            Stretch = 4
        }

        /// <summary>
        /// These errors can be emitted in response to wl_fullscreen_shell requests.<br/><br/>
        /// </summary>
        public enum ErrorEnum
        {
            /// <summary>
            /// present_method is not known<br/><br/>
            /// </summary>
            InvalidMethod = 0,
            /// <summary>
            /// given wl_surface has another role<br/><br/>
            /// </summary>
            Role = 1
        }

        private class ProxyFactory : IBindFactory<ZwpFullscreenShellV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.FullscreenShellUnstableV1.ZwpFullscreenShellV1.WlInterface);
            }

            public ZwpFullscreenShellV1 Create(IntPtr handle, int version)
            {
                return new ZwpFullscreenShellV1(handle, version);
            }
        }

        public static IBindFactory<ZwpFullscreenShellV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_fullscreen_shell_v1";
        public const int InterfaceVersion = 1;

        public ZwpFullscreenShellV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    public sealed unsafe partial class ZwpFullscreenShellModeFeedbackV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpFullscreenShellModeFeedbackV1()
        {
            NWayland.Protocols.FullscreenShellUnstableV1.ZwpFullscreenShellModeFeedbackV1.WlInterface = new WlInterface("zwp_fullscreen_shell_mode_feedback_v1", 1, new WlMessage[] { }, new WlMessage[] {
                new WlMessage("mode_successful", "", new WlInterface*[] { }),
                new WlMessage("mode_failed", "", new WlInterface*[] { }),
                new WlMessage("present_cancelled", "", new WlInterface*[] { })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.FullscreenShellUnstableV1.ZwpFullscreenShellModeFeedbackV1.WlInterface);
        }

        public interface IEvents
        {
            /// <summary>
            /// This event indicates that the attempted mode switch operation wassuccessful.  A surface of the size requested in the mode switchwill fill the output without scaling.<br/><br/>
            /// Upon receiving this event, the client should destroy thewl_fullscreen_shell_mode_feedback object.<br/><br/>
            /// </summary>
            void OnModeSuccessful(NWayland.Protocols.FullscreenShellUnstableV1.ZwpFullscreenShellModeFeedbackV1 eventSender);

            /// <summary>
            /// This event indicates that the attempted mode switch operationfailed.  This may be because the requested output mode is notpossible or it may mean that the compositor does not want to allow it.<br/><br/>
            /// Upon receiving this event, the client should destroy thewl_fullscreen_shell_mode_feedback object.<br/><br/>
            /// </summary>
            void OnModeFailed(NWayland.Protocols.FullscreenShellUnstableV1.ZwpFullscreenShellModeFeedbackV1 eventSender);

            /// <summary>
            /// This event indicates that the attempted mode switch operation wascancelled.  Most likely this is because the client requested asecond mode switch before the first one completed.<br/><br/>
            /// Upon receiving this event, the client should destroy thewl_fullscreen_shell_mode_feedback object.<br/><br/>
            /// </summary>
            void OnPresentCancelled(NWayland.Protocols.FullscreenShellUnstableV1.ZwpFullscreenShellModeFeedbackV1 eventSender);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnModeSuccessful(this);
                    break;
                case 1:
                    Events?.OnModeFailed(this);
                    break;
                case 2:
                    Events?.OnPresentCancelled(this);
                    break;
            }
        }

        private class ProxyFactory : IBindFactory<ZwpFullscreenShellModeFeedbackV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.FullscreenShellUnstableV1.ZwpFullscreenShellModeFeedbackV1.WlInterface);
            }

            public ZwpFullscreenShellModeFeedbackV1 Create(IntPtr handle, int version)
            {
                return new ZwpFullscreenShellModeFeedbackV1(handle, version);
            }
        }

        public static IBindFactory<ZwpFullscreenShellModeFeedbackV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_fullscreen_shell_mode_feedback_v1";
        public const int InterfaceVersion = 1;

        public ZwpFullscreenShellModeFeedbackV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }
}