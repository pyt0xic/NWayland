using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using NWayland.Protocols.Wayland;
using NWayland.Interop;
#nullable enable
// <auto-generated/>
namespace NWayland.Protocols.KeyboardShortcutsInhibitUnstableV1
{
    /// <summary>
    /// A global interface used for inhibiting the compositor keyboard shortcuts.<br/><br/>
    /// </summary>
    public sealed unsafe partial class ZwpKeyboardShortcutsInhibitManagerV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpKeyboardShortcutsInhibitManagerV1()
        {
            NWayland.Protocols.KeyboardShortcutsInhibitUnstableV1.ZwpKeyboardShortcutsInhibitManagerV1.WlInterface = new WlInterface("zwp_keyboard_shortcuts_inhibit_manager_v1", 1, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { }),
                new WlMessage("inhibit_shortcuts", "noo", new WlInterface*[] { WlInterface.GeneratorAddressOf(ref NWayland.Protocols.KeyboardShortcutsInhibitUnstableV1.ZwpKeyboardShortcutsInhibitorV1.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSurface.WlInterface), WlInterface.GeneratorAddressOf(ref NWayland.Protocols.Wayland.WlSeat.WlInterface) })
            }, new WlMessage[] { });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.KeyboardShortcutsInhibitUnstableV1.ZwpKeyboardShortcutsInhibitManagerV1.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        /// <summary>
        /// Create a new keyboard shortcuts inhibitor object associated withthe given surface for the given seat.<br/><br/>
        /// If shortcuts are already inhibited for the specified seat and surface,a protocol error "already_inhibited" is raised by the compositor.<br/><br/>
        /// </summary>
        public NWayland.Protocols.KeyboardShortcutsInhibitUnstableV1.ZwpKeyboardShortcutsInhibitorV1 InhibitShortcuts(NWayland.Protocols.Wayland.WlSurface @surface, NWayland.Protocols.Wayland.WlSeat @seat)
        {
            if (@seat == null)
                throw new ArgumentNullException("seat");
            if (@surface == null)
                throw new ArgumentNullException("surface");
            WlArgument* __args = stackalloc WlArgument[] {
                WlArgument.NewId,
                @surface,
                @seat
            };
            var __ret = LibWayland.wl_proxy_marshal_array_constructor_versioned(this.Handle, 1, __args, ref NWayland.Protocols.KeyboardShortcutsInhibitUnstableV1.ZwpKeyboardShortcutsInhibitorV1.WlInterface, (uint)this.Version);
            return __ret == IntPtr.Zero ? null : new NWayland.Protocols.KeyboardShortcutsInhibitUnstableV1.ZwpKeyboardShortcutsInhibitorV1(__ret, Version);
        }

        public interface IEvents
        {
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
        }

        public enum ErrorEnum
        {
            /// <summary>
            /// the shortcuts are already inhibited for this surface<br/><br/>
            /// </summary>
            AlreadyInhibited = 0
        }

        private class ProxyFactory : IBindFactory<ZwpKeyboardShortcutsInhibitManagerV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.KeyboardShortcutsInhibitUnstableV1.ZwpKeyboardShortcutsInhibitManagerV1.WlInterface);
            }

            public ZwpKeyboardShortcutsInhibitManagerV1 Create(IntPtr handle, int version)
            {
                return new ZwpKeyboardShortcutsInhibitManagerV1(handle, version);
            }
        }

        public static IBindFactory<ZwpKeyboardShortcutsInhibitManagerV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_keyboard_shortcuts_inhibit_manager_v1";
        public const int InterfaceVersion = 1;

        public ZwpKeyboardShortcutsInhibitManagerV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }

    /// <summary>
    /// A keyboard shortcuts inhibitor instructs the compositor to ignoreits own keyboard shortcuts when the associated surface has keyboardfocus. As a result, when the surface has keyboard focus on the givenseat, it will receive all key events originating from the specifiedseat, even those which would normally be caught by the compositor forits own shortcuts.<br/><br/>
    /// The Wayland compositor is however under no obligation to disableall of its shortcuts, and may keep some special key combo for its ownuse, including but not limited to one allowing the user to forciblyrestore normal keyboard events routing in the case of an unwillingclient. The compositor may also use the same key combo to reactivatean existing shortcut inhibitor that was previously deactivated onuser request.<br/><br/>
    /// When the compositor restores its own keyboard shortcuts, an"inactive" event is emitted to notify the client that the keyboardshortcuts inhibitor is not effectively active for the surface andseat any more, and the client should not expect to receive allkeyboard events.<br/><br/>
    /// When the keyboard shortcuts inhibitor is inactive, the client hasno way to forcibly reactivate the keyboard shortcuts inhibitor.<br/><br/>
    /// The user can chose to re-enable a previously deactivated keyboardshortcuts inhibitor using any mechanism the compositor may offer,in which case the compositor will send an "active" event to notifythe client.<br/><br/>
    /// If the surface is destroyed, unmapped, or loses the seat's keyboardfocus, the keyboard shortcuts inhibitor becomes irrelevant and thecompositor will restore its own keyboard shortcuts but no "inactive"event is emitted in this case.<br/><br/>
    /// </summary>
    public sealed unsafe partial class ZwpKeyboardShortcutsInhibitorV1 : WlProxy
    {
        [FixedAddressValueType]
        public static WlInterface WlInterface;

        static ZwpKeyboardShortcutsInhibitorV1()
        {
            NWayland.Protocols.KeyboardShortcutsInhibitUnstableV1.ZwpKeyboardShortcutsInhibitorV1.WlInterface = new WlInterface("zwp_keyboard_shortcuts_inhibitor_v1", 1, new WlMessage[] {
                new WlMessage("destroy", "", new WlInterface*[] { })
            }, new WlMessage[] {
                new WlMessage("active", "", new WlInterface*[] { }),
                new WlMessage("inactive", "", new WlInterface*[] { })
            });
        }

        protected override WlInterface* GetWlInterface()
        {
            return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.KeyboardShortcutsInhibitUnstableV1.ZwpKeyboardShortcutsInhibitorV1.WlInterface);
        }

        protected override void Dispose(bool disposing)
        {
            WlArgument* __args = stackalloc WlArgument[] {
            };
            LibWayland.wl_proxy_marshal_array(this.Handle, 0, __args);
            base.Dispose(true);
        }

        public interface IEvents
        {
            /// <summary>
            /// This event indicates that the shortcut inhibitor is active.<br/><br/>
            /// The compositor sends this event every time compositor shortcutsare inhibited on behalf of the surface. When active, the clientmay receive input events normally reserved by the compositor(see zwp_keyboard_shortcuts_inhibitor_v1).<br/><br/>
            /// This occurs typically when the initial request "inhibit_shortcuts"first becomes active or when the user instructs the compositor tore-enable and existing shortcuts inhibitor using any mechanismoffered by the compositor.<br/><br/>
            /// </summary>
            void OnActive(NWayland.Protocols.KeyboardShortcutsInhibitUnstableV1.ZwpKeyboardShortcutsInhibitorV1 eventSender);

            /// <summary>
            /// This event indicates that the shortcuts inhibitor is inactive,normal shortcuts processing is restored by the compositor.<br/><br/>
            /// </summary>
            void OnInactive(NWayland.Protocols.KeyboardShortcutsInhibitUnstableV1.ZwpKeyboardShortcutsInhibitorV1 eventSender);
        }

        public IEvents? Events { get; set; }

        protected override void DispatchEvent(uint opcode, WlArgument* arguments)
        {
            switch (opcode)
            {
                case 0:
                    Events?.OnActive(this);
                    break;
                case 1:
                    Events?.OnInactive(this);
                    break;
            }
        }

        private class ProxyFactory : IBindFactory<ZwpKeyboardShortcutsInhibitorV1>
        {
            public WlInterface* GetInterface()
            {
                return WlInterface.GeneratorAddressOf(ref NWayland.Protocols.KeyboardShortcutsInhibitUnstableV1.ZwpKeyboardShortcutsInhibitorV1.WlInterface);
            }

            public ZwpKeyboardShortcutsInhibitorV1 Create(IntPtr handle, int version)
            {
                return new ZwpKeyboardShortcutsInhibitorV1(handle, version);
            }
        }

        public static IBindFactory<ZwpKeyboardShortcutsInhibitorV1> BindFactory { get; } = new ProxyFactory();

        public const string InterfaceName = "zwp_keyboard_shortcuts_inhibitor_v1";
        public const int InterfaceVersion = 1;

        public ZwpKeyboardShortcutsInhibitorV1(IntPtr handle, int version) : base(handle, version)
        {
        }
    }
}